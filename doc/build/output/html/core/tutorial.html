

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="ko" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="ko" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>SQL 표현식 언어 튜토리얼 &mdash; SQLAlchemy 1.3.0b1 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/changelog.css" type="text/css" />
  <link rel="stylesheet" href="../_static/sphinx_paramlinks.css" type="text/css" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="SQL Statements and Expressions API" href="expression_api.html" />
    <link rel="prev" title="SQLAlchemy Core" href="index.html" /> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../contents.html" class="icon icon-home"> SQLAlchemy
          

          
          </a>

          
            
            
              <div class="version">
                1.3
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../intro.html">개요</a></li>
<li class="toctree-l1"><a class="reference internal" href="../orm/index.html">SQLAlchemy ORM</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">SQLAlchemy Core</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">SQL 표현식 언어 튜토리얼</a></li>
<li class="toctree-l2"><a class="reference internal" href="expression_api.html">SQL Statements and Expressions API</a></li>
<li class="toctree-l2"><a class="reference internal" href="schema.html">Schema Definition Language</a></li>
<li class="toctree-l2"><a class="reference internal" href="types.html">Column and Data Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="engines_connections.html">Engine and Connection Use</a></li>
<li class="toctree-l2"><a class="reference internal" href="api_basics.html">Core API Basics</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../dialects/index.html">Dialects</a></li>
<li class="toctree-l1"><a class="reference internal" href="../faq/index.html">Frequently Asked Questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../errors.html">Error Messages</a></li>
<li class="toctree-l1"><a class="reference internal" href="../changelog/index.html">Changes and Migration</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../contents.html">SQLAlchemy</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../contents.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">SQLAlchemy Core</a> &raquo;</li>
        
      <li>SQL 표현식 언어 튜토리얼</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            
              <a href="https://github.com/VeranosTech/docs-korean-sqlalchemy//docs-korean/doc/build/core/tutorial.rst" class="fa fa-github"> Edit on GitHub</a>
            
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="sql-expression-language-tutorial">
<span id="sqlexpression-toplevel"></span><h1>SQL 표현식 언어 튜토리얼<a class="headerlink" href="#sql-expression-language-tutorial" title="제목 주소">¶</a></h1>
<p>SQLAlchemy Expression Language(이하 <cite>표현식 언어</cite>로 표기)는 Python 구문을 사용하여 관계형 데이터베이스 구조 및 표현을 나타내는 시스템을 제공한다. 이러한 구조는 데이터베이스 백엔드 간의 다양한 구현 차이에 대한 추상화를 제공하는 동시에 가능한 기본 데이터베이스와 유사하도록 모델링된다. 구조가 일관된 구조로 백엔드간에 동일한 개념을 표현하기 위해 시도하는 동안 백엔드의 특정 서브세트에 고유한 실용적인 개념을 숨기지는 않는다. 따라서 표현식 언어는 백엔드-중립적인(backend-neutral) SQL 표현식을 작성하는 방법을 제시하지만 백엔드-중립적인 표현식을 강요하지는 않는다.</p>
<p>표현식 언어는 표현 언어를 기반으로한 ORM(Object Relational Mapper)와 대조적입니다. <a class="reference internal" href="../orm/tutorial.html#ormtutorial-toplevel"><span class="std std-ref">ORM 튜토리얼</span></a>에 소개된 ORM은 높은 수준의 추상화 패턴을 사용하지만(이것 자체로도 표현식 언어의 응용), 표현식 언어는 관계형 데이터베이스의 기본 구조를 직접 구현하는 시스템을 제공한다.</p>
<p>ORM과 표현식 언어의 사용 패턴이 겹치는 동안 유사점들은 처음에 나타날 수 있는 것보다 더 피상적(superficial) 이다. 그 중 하나는 사용자 정의 도메인 모델 <a class="reference external" href="http://en.wikipedia.org/wiki/Domain_model">domain model</a>의 관점에서 데이터의 구조와 내용에 접근하여 투명하게 유지되며 기본 저장소 모델에서 새로 고쳐진다는 것이다.다른 하나는 리터럴 스키마와 명시적으로 데이터베이스에서 개별적으로 소비되는 메시지로 구성된 SQL 표현식(expression)의 표현들(representations)의 관점에서 접근한다.</p>
<p>어플리케이션의 개념(concepts)을 개별 데이터베이스 메시지 및 개별 데이터베이스 결과 집합으로 변환하는교유한 시스템을 어플리케이션내에서 정의해야 하지만, 표현식 언어를 독점적으로(exclusively) 사용하여 성공적인 어플리케이션을 개발할 수 있다. 또는 ORM으로 구성된 어플리케이션의 경우 복잡한 시나리오에서 데이터베이스와 상호작용이 필요한 특정 부분에 직접 표현식 언어를 간헐적으로 사용할 수 있다.</p>
<p>아래의 튜토리얼은 doctest 형식으로 되어있다. 즉 <code class="docutils literal notranslate"><span class="pre">&gt;&gt;&gt;</span></code> 행은 파이썬 명령 프롬프트에서 입력 할 수 있는 것을 나타내며, 다음 텍스트는 예상되는 반환 값을 타나낸다.현재 튜토리얼에는 준비해야할것(prerequisites)이 없다.</p>
<div class="section" id="version-check">
<h2>버젼 확인<a class="headerlink" href="#version-check" title="제목 주소">¶</a></h2>
<p>우리가 가장 최신 버전인 <strong>version 1.3</strong>SQLAlchemy 를 사용하고 있는지 확인:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sqlalchemy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sqlalchemy</span><span class="o">.</span><span class="n">__version__</span>  <span class="c1"># doctest: +SKIP</span>
<span class="go">1.3.0</span>
</pre></div>
</div>
</div>
<div class="section" id="connecting">
<h2>연결<a class="headerlink" href="#connecting" title="제목 주소">¶</a></h2>
<p>이 튜토리얼을 위해 우리는 in-memory-only SQLite 데이터베이스를 사용한다.이것은 실제 데이터베이스를 가질 필요 없이 쉽게 어디서든 테스트를 할 수 있게 한다.:func:<cite>~sqlalchemy.create_engine</cite>함수를 통해 접속한다.</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">create_engine</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">engine</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s1">&#39;sqlite:///:memory:&#39;</span><span class="p">,</span> <span class="n">echo</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">echo</span></code> 플래는 SQLAlchemy의 로깅 설정을 할 수 있는 가장 빠른 길이다. 이것은 파이썬 표준 라이브러리인 <code class="docutils literal notranslate"><span class="pre">logging</span></code> 모듈을 사용한다. 이 설정이 허용되면 우리는 SQL에서 생성된 것들을 볼 수 있다.</p>
<p><a class="reference internal" href="engines.html#sqlalchemy.create_engine" title="sqlalchemy.create_engine"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_engine()</span></code></a>함수에서 반환되는 값은 <a class="reference internal" href="connections.html#sqlalchemy.engine.Engine" title="sqlalchemy.engine.Engine"><code class="xref py py-class docutils literal notranslate"><span class="pre">Engine</span></code></a>의 인스턴스 이다, 이것은 데이터베이스의 핵심 인터페이스를 나타내며 사용중인 데이터베이스 및 <a class="reference internal" href="../glossary.html#term-dbapi"><span class="xref std std-term">DBAPI</span></a>의세부 정보를 처리하는 <span class="xref std std-term">dialect</span>를 통해 핸들링된다. 이 경우 SQLite dialect는 파이썬내장 모듈 <code class="docutils literal notranslate"><span class="pre">sqlite3</span></code>에 대한 명령어를 해석 한다.</p>
<div class="sidebar">
<p class="first sidebar-title">게으른 연결</p>
<p class="last"><a class="reference internal" href="engines.html#sqlalchemy.create_engine" title="sqlalchemy.create_engine"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_engine()</span></code></a>함수에 의해 처음으로 반환되는 <a class="reference internal" href="connections.html#sqlalchemy.engine.Engine" title="sqlalchemy.engine.Engine"><code class="xref py py-class docutils literal notranslate"><span class="pre">Engine</span></code></a>는 사실 아직 데이터베이스에 연결을 하지 않았다. 데이터베이스에 대해 작업을 수행하라는 메시지가 처음 실행될 때만 연결이 발생한다.</p>
</div>
<p><a class="reference internal" href="connections.html#sqlalchemy.engine.Engine.execute" title="sqlalchemy.engine.Engine.execute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Engine.execute()</span></code></a>함수나 <a class="reference internal" href="connections.html#sqlalchemy.engine.Engine.connect" title="sqlalchemy.engine.Engine.connect"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Engine.connect()</span></code></a>함수가 처음 호출되었을때 <a class="reference internal" href="connections.html#sqlalchemy.engine.Engine" title="sqlalchemy.engine.Engine"><code class="xref py py-class docutils literal notranslate"><span class="pre">Engine</span></code></a>클래스는 <a class="reference internal" href="../glossary.html#term-dbapi"><span class="xref std std-term">DBAPI</span></a>연결을 데이터베이스와 설정한 다음 <a class="reference internal" href="../glossary.html#term-dbapi"><span class="xref std std-term">DBAPI</span></a>을 통해 SQL을 내보낸다.</p>
<div class="admonition seealso">
<p class="first admonition-title">더 보기</p>
<p class="last"><a class="reference internal" href="engines.html#database-urls"><span class="std std-ref">Database Urls</span></a> - <a class="reference internal" href="engines.html#sqlalchemy.create_engine" title="sqlalchemy.create_engine"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_engine()</span></code></a>함수를 통해 데이터베이스와 연결하는 몇 가지 방법들에 대해 좀 더 자세한 설명과 예제가 나와있다.</p>
</div>
</div>
<div class="section" id="define-and-create-tables">
<h2>테이블 정의와 생성<a class="headerlink" href="#define-and-create-tables" title="제목 주소">¶</a></h2>
<p>SQL 표현식 언어는 대부분의 경우 테이블 컬럼에 대한 표현식들을 생성한다. SQLAlchemy 에서 대부분 컬럼은 <a class="reference internal" href="metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a>객체를 호출됨으로서 표현되어지고, 모든 경우에서 <a class="reference internal" href="metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a>은 <a class="reference internal" href="metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>과연관되어져 있다. <a class="reference internal" href="metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>개체들의 컬랙션과 이들과 연관된 아직 객체들은 <strong>database metadata</strong>로 참조되어 진다. 이 튜토리얼에서 우리는 명시적으로 몇몇의 <a class="reference internal" href="metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>객체들을 배치하지만 SQLAlchemy는 또한 이미 존재하는 데이베이스에서 <a class="reference internal" href="metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>객체 전체 집합을 자동적으로 &quot;import&quot;할 수 있다.(이 과정을 <strong>테이블 리플렉션(table reflection)</strong>이라고 부른다.)</p>
<p>우리는 일반적인 SQL CREATE TABLE문과 비슷한 뜻을 가진 <a class="reference internal" href="metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>객체 생성함으로서모든 테이블들을 <a class="reference internal" href="metadata.html#sqlalchemy.schema.MetaData" title="sqlalchemy.schema.MetaData"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaData</span></code></a>라 불리는 카테로그(catalog)에 정의했다.</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">Table</span><span class="p">,</span> <span class="n">Column</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">String</span><span class="p">,</span> <span class="n">MetaData</span><span class="p">,</span> <span class="n">ForeignKey</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">metadata</span> <span class="o">=</span> <span class="n">MetaData</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">users</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="s1">&#39;users&#39;</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="bp">True</span><span class="p">),</span>
<span class="gp">... </span>    <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="n">String</span><span class="p">),</span>
<span class="gp">... </span>    <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;fullname&#39;</span><span class="p">,</span> <span class="n">String</span><span class="p">),</span>
<span class="gp">... </span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">addresses</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="s1">&#39;addresses&#39;</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span>
<span class="gp">... </span>  <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="bp">True</span><span class="p">),</span>
<span class="gp">... </span>  <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;user_id&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">(</span><span class="s1">&#39;users.id&#39;</span><span class="p">)),</span>
<span class="gp">... </span>  <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;email_address&#39;</span><span class="p">,</span> <span class="n">String</span><span class="p">,</span> <span class="n">nullable</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">... </span> <span class="p">)</span>
</pre></div>
</div>
<p>이미 존재하는 데이터베이스에서 자동적으로 테이블 객체를 정의하는 방법부터 <a class="reference internal" href="metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>객체를 정의하는 모든 방법은 <a class="reference internal" href="metadata.html#metadata-toplevel"><span class="std std-ref">Describing Databases with MetaData</span></a>에 설명되어 있다.</p>
<p>다음으로, <a class="reference internal" href="metadata.html#sqlalchemy.schema.MetaData" title="sqlalchemy.schema.MetaData"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaData</span></code></a>을 말하자면 <a class="reference internal" href="metadata.html#sqlalchemy.schema.MetaData" title="sqlalchemy.schema.MetaData"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaData</span></code></a>안에 있는 우리가 선택한 테이블들을 실제 SQLite 데이터 베이스 안에생성하고 싶을땐 <a class="reference internal" href="metadata.html#sqlalchemy.schema.MetaData.create_all" title="sqlalchemy.schema.MetaData.create_all"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_all()</span></code></a>함수에 데이터베이스의 엔드포인트를 가르키는 <code class="docutils literal notranslate"><span class="pre">engine</span></code>객체를 넣어줌으로서 할 수 있다. 이렇게 하면 각 테이블을 생성하기 전에 테이블의 존재 여부를 먼저확인하므로 여러 번 호출하는 것이 안전하다:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class=" -Sql -Sql-Link">{sql}</span><span class="gp">&gt;&gt;&gt; </span><span class="n">metadata</span><span class="o">.</span><span class="n">create_all</span><span class="p">(</span><span class="n">engine</span><span class="p">)</span>
<span class="go">SE...</span>
<span class=" -Sql -Sql-Popup">CREATE TABLE users (</span>
<span class=" -Sql -Sql-Popup">    id INTEGER NOT NULL,</span>
<span class=" -Sql -Sql-Popup">    name VARCHAR,</span>
<span class=" -Sql -Sql-Popup">    fullname VARCHAR,</span>
<span class=" -Sql -Sql-Popup">    PRIMARY KEY (id)</span>
<span class=" -Sql -Sql-Popup">)</span>
<span class=" -Sql -Sql-Popup">()</span>
<span class=" -Sql -Sql-Popup">COMMIT</span>
<span class=" -Sql -Sql-Popup">CREATE TABLE addresses (</span>
<span class=" -Sql -Sql-Popup">    id INTEGER NOT NULL,</span>
<span class=" -Sql -Sql-Popup">    user_id INTEGER,</span>
<span class=" -Sql -Sql-Popup">    email_address VARCHAR NOT NULL,</span>
<span class=" -Sql -Sql-Popup">    PRIMARY KEY (id),</span>
<span class=" -Sql -Sql-Popup">    FOREIGN KEY(user_id) REFERENCES users (id)</span>
<span class=" -Sql -Sql-Popup">)</span>
<span class=" -Sql -Sql-Popup">()</span>
<span class=" -Sql -Sql-Popup">COMMIT</span><span class="go"></span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p>CREATE TABLE 문법과 친숙한 사용자들이라면 VARCHAR 컬럼들이 길이 없이 생성됨을 알아차렸을 것이다. SQLite 와 PostgreSQL 에서 이것은 올바른 데이터 타입이지만 다른 데이터베이스에선 이것이 허락되지 않는다. 따라서 아래 예제와 같이 다른 데이터베이스에서 이 튜토리얼을 실행하고 있다면, SQLAlchemy를 사용하여 CREATE TABLE문을 사용할 땐 &quot;길이&quot; 를 <a class="reference internal" href="type_basics.html#sqlalchemy.types.String" title="sqlalchemy.types.String"><code class="xref py py-class docutils literal notranslate"><span class="pre">String</span></code></a>에 할당 해주어야 한다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Column</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">))</span>
</pre></div>
</div>
<p><a class="reference internal" href="type_basics.html#sqlalchemy.types.String" title="sqlalchemy.types.String"><code class="xref py py-class docutils literal notranslate"><span class="pre">String</span></code></a>의 길이 항목처럼 <a class="reference internal" href="type_basics.html#sqlalchemy.types.Integer" title="sqlalchemy.types.Integer"><code class="xref py py-class docutils literal notranslate"><span class="pre">Integer</span></code></a>와 <a class="reference internal" href="type_basics.html#sqlalchemy.types.Numeric" title="sqlalchemy.types.Numeric"><code class="xref py py-class docutils literal notranslate"><span class="pre">Numeric</span></code></a>에서 마찬가지로 정밀도/스케일 항목이 존재한다.</p>
<p>추가적으로, Firebird와 오라클에선 새로운 프라이머리 키 식별자를 생성하기 위해 시퀸스가 필요하다.SQLAlchemy는 지시없이 이러한 식별자를 생성하거나 시퀸스를 가정하지 않는다. 이것을 위해 <a class="reference internal" href="defaults.html#sqlalchemy.schema.Sequence" title="sqlalchemy.schema.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code></a>를 사용할 수 있다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">Sequence</span>
<span class="n">Column</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">(</span><span class="s1">&#39;user_id_seq&#39;</span><span class="p">),</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>따라서 완전한 <a class="reference internal" href="metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>구현은 다음과 같다:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">users</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="s1">&#39;users&#39;</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span>
   <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">(</span><span class="s1">&#39;user_id_seq&#39;</span><span class="p">),</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
   <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">)),</span>
   <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;fullname&#39;</span><span class="p">,</span> <span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">)),</span>
   <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;nickname&#39;</span><span class="p">,</span> <span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">))</span>
<span class="p">)</span>
</pre></div>
</div>
<p class="last">더 엄격한 요구 사항을 가진 특정 백엔드 세트에서 CREATE TABLE 문을 발행하는데 사용되는것과 파이썬에서만 사용되는 최소 구문으로 CREATE TABLE 문을 발행하는데 사용되는 것의 차이를 강조하기 위해 <a class="reference internal" href="metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>에 좀 더 많은 구문(verbose)를 포함했다.</p>
</div>
</div>
<div class="section" id="insert-expressions">
<span id="coretutorial-insert-expressions"></span><h2>삽입 표현식<a class="headerlink" href="#insert-expressions" title="제목 주소">¶</a></h2>
<p>우리가 처음으로 만들 SQL 표현식은 <a class="reference internal" href="dml.html#sqlalchemy.sql.expression.Insert" title="sqlalchemy.sql.expression.Insert"><code class="xref py py-class docutils literal notranslate"><span class="pre">Insert</span></code></a>구조이다.이것은 INSERT문을 표현하며, 이것은 일반적으로 타겟 테이블을 기준으로 생성되어 진다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ins</span> <span class="o">=</span> <span class="n">users</span><span class="o">.</span><span class="n">insert</span><span class="p">()</span>
</pre></div>
</div>
<p>이 SQL이 생성하는 구조를 보려면 아래와 같이 <code class="docutils literal notranslate"><span class="pre">str()</span></code> 함수를 사용한다:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">str</span><span class="p">(</span><span class="n">ins</span><span class="p">)</span>
<span class="go">&#39;INSERT INTO users (id, name, fullname) VALUES (:id, :name, :fullname)&#39;</span>
</pre></div>
</div>
<p>위에서 INSERT문이 <code class="docutils literal notranslate"><span class="pre">user</span></code>테이블의 모든 컬럼의 이름을 지정하는 것을 주목해라. 모든 컬럼의 이름을 지정하는 것을 제한할 수 있는데, <code class="docutils literal notranslate"><span class="pre">values()</span></code> 메소드 사용해서 INSERT문의 VALUES절을 명시적으로 설정할 수 있다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ins</span> <span class="o">=</span> <span class="n">users</span><span class="o">.</span><span class="n">insert</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;jack&#39;</span><span class="p">,</span> <span class="n">fullname</span><span class="o">=</span><span class="s1">&#39;Jack Jones&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">str</span><span class="p">(</span><span class="n">ins</span><span class="p">)</span>
<span class="go">&#39;INSERT INTO users (name, fullname) VALUES (:name, :fullname)&#39;</span>
</pre></div>
</div>
<p>위의 <code class="docutils literal notranslate"><span class="pre">values</span></code>메소드는 VALUES 절을 단지 두 개의 컬럼으로 제한했지만 실제로 배치한 데이터``values``는 문자열로 렌더링되지 않았다. 대신 우리는 이름이 설정된 바인드 매개 변수를 얻었다.결과적으로 <strong>데이터는</strong>  <a class="reference internal" href="dml.html#sqlalchemy.sql.expression.Insert" title="sqlalchemy.sql.expression.Insert"><code class="xref py py-class docutils literal notranslate"><span class="pre">Insert</span></code></a>구조 내에 저장 되지만, 일반적으로 명령문이 실제로 실행될 때만 나타납니다. 데이터가 리터럴 값으로 구성되므로 SQLAlchemy는 자동으로 바인드 매개 변수를 생성합니다. 컴파일 된 형태의 명세서를 보면이 데이터를 볼 수 있습니다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ins</span><span class="o">.</span><span class="n">compile</span><span class="p">()</span><span class="o">.</span><span class="n">params</span>  
<span class="go">{&#39;fullname&#39;: &#39;Jack Jones&#39;, &#39;name&#39;: &#39;jack&#39;}</span>
</pre></div>
</div>
</div>
<div class="section" id="executing">
<h2>실행<a class="headerlink" href="#executing" title="제목 주소">¶</a></h2>
<p><a class="reference internal" href="dml.html#sqlalchemy.sql.expression.Insert" title="sqlalchemy.sql.expression.Insert"><code class="xref py py-class docutils literal notranslate"><span class="pre">Insert</span></code></a>의 흥미로운 부분은 이것을 실행하는 것이다.이 튜토리얼에서 우리는 일반적으로 SQL 구문을 실행하는 가장 명확한 방법에 초점을 맞추고 나중에 &quot;지름길&quot;을 통해 실행할 것이다. 우리가 생성한 <code class="docutils literal notranslate"><span class="pre">engine</span></code>객체는 데이터베이스에 SQL을 발행할 수 있는 데이터 베이스 연결 케이블들의 저장소이다. 데이터베이스와 연결을 얻으려면 <code class="docutils literal notranslate"><span class="pre">connect()</span></code>함수를 사용한다:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span> <span class="o">=</span> <span class="n">engine</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span>
<span class="go">&lt;sqlalchemy.engine.base.Connection object at 0x...&gt;</span>
</pre></div>
</div>
<p><a class="reference internal" href="connections.html#sqlalchemy.engine.Connection" title="sqlalchemy.engine.Connection"><code class="xref py py-class docutils literal notranslate"><span class="pre">Connection</span></code></a>객체는 체크-아웃(checked-out) DBAPI 연결 자원을 나타낸다. <a class="reference internal" href="dml.html#sqlalchemy.sql.expression.Insert" title="sqlalchemy.sql.expression.Insert"><code class="xref py py-class docutils literal notranslate"><span class="pre">Insert</span></code></a>객체에 피드를 보내고 어떤 일이 발생하는지 살펴 본다:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">ins</span><span class="p">)</span>
<span class=" -Sql -Sql-Open">{opensql}</span><span class=" -Sql">INSERT INTO users (name, fullname) VALUES (?, ?)</span>
<span class=" -Sql">(&#39;jack&#39;, &#39;Jack Jones&#39;)</span>
<span class=" -Sql">COMMIT</span><span class="go"></span>
</pre></div>
</div>
<p>이제 INSERT문이 데이터베이스에 발행되었습니다. &quot;명명 된&quot; 바인드 파라미터를 얻는 대신위치적인(positional) &quot;?&quot;바인드 파라미터를 얻었다. 왜냐하면 이것이 실행될때 <a class="reference internal" href="connections.html#sqlalchemy.engine.Connection" title="sqlalchemy.engine.Connection"><code class="xref py py-class docutils literal notranslate"><span class="pre">Connection</span></code></a>가 SQLite <strong>dialect</strong>를 사용하여 이 구문을 생성하기 때문이다. <code class="docutils literal notranslate"><span class="pre">str()</span></code>함수를 사용할 때, 명령문은 이 dialect를 인식 하지 못하고 명명된 매개 변수를 사용하는 기본값으로 되돌아간다. 아래와 같이 이 과정을수동으로 볼 수 있다:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ins</span><span class="o">.</span><span class="n">bind</span> <span class="o">=</span> <span class="n">engine</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">str</span><span class="p">(</span><span class="n">ins</span><span class="p">)</span>
<span class="go">&#39;INSERT INTO users (name, fullname) VALUES (?, ?)&#39;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">execute()</span></code>를 호출했을때 어떤 <code class="docutils literal notranslate"><span class="pre">result</span></code>변수를 받는가 ? <a class="reference internal" href="connections.html#sqlalchemy.engine.ResultProxy" title="sqlalchemy.engine.ResultProxy"><code class="xref py py-class docutils literal notranslate"><span class="pre">ResultProxy</span></code></a>객체로도 알려진 DBAPI 연결을 참조하는 <a class="reference internal" href="connections.html#sqlalchemy.engine.Connection" title="sqlalchemy.engine.Connection"><code class="xref py py-class docutils literal notranslate"><span class="pre">Connection</span></code></a>객체는 DB:class:<cite>~sqlalchemy.engine.Connection</cite>객체가 DBAPI 연결을 참조하므로, <a class="reference internal" href="connections.html#sqlalchemy.engine.ResultProxy" title="sqlalchemy.engine.ResultProxy"><code class="xref py py-class docutils literal notranslate"><span class="pre">ResultProxy</span></code></a>객체로도 알려져있는 <strong>결과</strong> 객체는 DBAPI의 커서 객체와 유사하다. INSERT의 경우 <a class="reference internal" href="connections.html#sqlalchemy.engine.ResultProxy.inserted_primary_key" title="sqlalchemy.engine.ResultProxy.inserted_primary_key"><code class="xref py py-attr docutils literal notranslate"><span class="pre">ResultProxy.inserted_primary_key</span></code></a>을 사용하여우리의 명령문에서 생성된 기본 키 값과 같이 중요한 정보를 얻을 수 있다.</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">result</span><span class="o">.</span><span class="n">inserted_primary_key</span>
<span class="go">[1]</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">1</span></code>값은 SQLite에 의해 자동적으로 생성되었지만, 우리가 <a class="reference internal" href="dml.html#sqlalchemy.sql.expression.Insert" title="sqlalchemy.sql.expression.Insert"><code class="xref py py-class docutils literal notranslate"><span class="pre">Insert</span></code></a>문에 <code class="docutils literal notranslate"><span class="pre">id</span></code> 컬럼을 지정하지 않았기 때문에 발생했다. 이렇지 않으면 우리의가 지정한 명시적 값이 사용되었을 것이다.두 경우 모두 SQLAlchemy가 새로 생성된 기본 키 값을 생성하는 방법을 알고있고 심지어 종류가 다른 데이터베이스들의  각각 다른 방법이 존재해도 이는 유효하다.각 데이터베이스의 <a class="reference internal" href="internals.html#sqlalchemy.engine.interfaces.Dialect" title="sqlalchemy.engine.interfaces.Dialect"><code class="xref py py-class docutils literal notranslate"><span class="pre">Dialect</span></code></a>는 올바른 값(또는 값; <a class="reference internal" href="connections.html#sqlalchemy.engine.ResultProxy.inserted_primary_key" title="sqlalchemy.engine.ResultProxy.inserted_primary_key"><code class="xref py py-attr docutils literal notranslate"><span class="pre">ResultProxy.inserted_primary_key</span></code></a>는 복합 기본 키(composite primary key)를 생성하는 리스트를 반환함을참고한다)을 결정하는 데 필요한 특정 단계을 알고 있다. 여기에는 <code class="docutils literal notranslate"><span class="pre">cursor.lastrowid</span></code> 부터 데이터베이스-지정 함수 선택, <code class="docutils literal notranslate"><span class="pre">INSERT..RETURNING</span></code>까지 다양한 메소드들이 있다. 모든 것들이 투명하게 실행된다.</p>
</div>
<div class="section" id="executing-multiple-statements">
<span id="execute-multiple"></span><h2>다중 구문 실행<a class="headerlink" href="#executing-multiple-statements" title="제목 주소">¶</a></h2>
<p>위의 INSERT 예제에서는 의도적으로 표현식 언어 구조들의 다양한 동작들이 어떻게 실행되는지 보였다. 하지만 일반적으로 <a class="reference internal" href="dml.html#sqlalchemy.sql.expression.Insert" title="sqlalchemy.sql.expression.Insert"><code class="xref py py-class docutils literal notranslate"><span class="pre">Insert</span></code></a>구문은 <a class="reference internal" href="connections.html#sqlalchemy.engine.Connection" title="sqlalchemy.engine.Connection"><code class="xref py py-class docutils literal notranslate"><span class="pre">Connection</span></code></a>클래스의 <code class="docutils literal notranslate"><span class="pre">execute()</span></code>함수의 파라미터를지정하여 사용된다. 따라서 <a class="reference internal" href="dml.html#sqlalchemy.sql.expression.Insert" title="sqlalchemy.sql.expression.Insert"><code class="xref py py-class docutils literal notranslate"><span class="pre">Insert</span></code></a>를 사용할때 <code class="docutils literal notranslate"><span class="pre">values</span></code>키워드는 사용될 필요가 없다. 제네릭 <a class="reference internal" href="dml.html#sqlalchemy.sql.expression.Insert" title="sqlalchemy.sql.expression.Insert"><code class="xref py py-class docutils literal notranslate"><span class="pre">Insert</span></code></a>구문을 생성하고 그것을 &quot;일반적인&quot; 방법으로 사용해 본다:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ins</span> <span class="o">=</span> <span class="n">users</span><span class="o">.</span><span class="n">insert</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">ins</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;wendy&#39;</span><span class="p">,</span> <span class="n">fullname</span><span class="o">=</span><span class="s1">&#39;Wendy Williams&#39;</span><span class="p">)</span>
<span class=" -Sql -Sql-Open">{opensql}</span><span class=" -Sql">INSERT INTO users (id, name, fullname) VALUES (?, ?, ?)</span>
<span class=" -Sql">(2, &#39;wendy&#39;, &#39;Wendy Williams&#39;)</span>
<span class=" -Sql">COMMIT</span>
<span class=" -Sql">{stop}</span><span class="go">&lt;sqlalchemy.engine.result.ResultProxy object at 0x...&gt;</span>
</pre></div>
</div>
<p>위의 예제에서 우리가 <code class="docutils literal notranslate"><span class="pre">execute()</span></code>안에 있는 모든 세 컬럼을 지정했기 때문에 <a class="reference internal" href="dml.html#sqlalchemy.sql.expression.Insert" title="sqlalchemy.sql.expression.Insert"><code class="xref py py-class docutils literal notranslate"><span class="pre">Insert</span></code></a>클래스는 이 모든 컬럼들을 컴파일 한다.:class:<cite>~.expression.Insert</cite>구문은 우리가 파라미터를 지정한 실행시간(execution-time)에 컴파일된다. 만약 우리가 더 적은 파라미터를 지정했다면 <a class="reference internal" href="dml.html#sqlalchemy.sql.expression.Insert" title="sqlalchemy.sql.expression.Insert"><code class="xref py py-class docutils literal notranslate"><span class="pre">Insert</span></code></a>는 더 적은 VALUES 절을 포함했을 것이다.</p>
<p>DBAPI의 <code class="docutils literal notranslate"><span class="pre">executemany()</span></code> 함수를 사용하여 많은 INSERT를 발행한다면 우리는 아래와 같이 INSERT될 각각의 파라미터를 포함하는 사전의 리스트를 <code class="docutils literal notranslate"><span class="pre">execute()</span></code>의 파라미터로 보낸다.</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">addresses</span><span class="o">.</span><span class="n">insert</span><span class="p">(),</span> <span class="p">[</span>
<span class="gp">... </span>   <span class="p">{</span><span class="s1">&#39;user_id&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;email_address&#39;</span> <span class="p">:</span> <span class="s1">&#39;jack@yahoo.com&#39;</span><span class="p">},</span>
<span class="gp">... </span>   <span class="p">{</span><span class="s1">&#39;user_id&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;email_address&#39;</span> <span class="p">:</span> <span class="s1">&#39;jack@msn.com&#39;</span><span class="p">},</span>
<span class="gp">... </span>   <span class="p">{</span><span class="s1">&#39;user_id&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;email_address&#39;</span> <span class="p">:</span> <span class="s1">&#39;www@www.org&#39;</span><span class="p">},</span>
<span class="gp">... </span>   <span class="p">{</span><span class="s1">&#39;user_id&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;email_address&#39;</span> <span class="p">:</span> <span class="s1">&#39;wendy@aol.com&#39;</span><span class="p">},</span>
<span class="gp">... </span><span class="p">])</span>
<span class=" -Sql -Sql-Open">{opensql}</span><span class=" -Sql">INSERT INTO addresses (user_id, email_address) VALUES (?, ?)</span>
<span class=" -Sql">((1, &#39;jack@yahoo.com&#39;), (1, &#39;jack@msn.com&#39;), (2, &#39;www@www.org&#39;), (2, &#39;wendy@aol.com&#39;))</span>
<span class=" -Sql">COMMIT</span>
<span class=" -Sql">{stop}</span><span class="go">&lt;sqlalchemy.engine.result.ResultProxy object at 0x...&gt;</span>
</pre></div>
</div>
<p>위의 예제에서, 우리는 또다시 각 <code class="docutils literal notranslate"><span class="pre">addresses</span></code>행에 SQLite 의 기본 키 식별자 자동 생성에 의존하였다.</p>
<p>다중 매개 변수 집합을 실행할때 각 사전에는 <strong>동일한</strong> 키 집합이 있어야 한다. 예를들어 어떤 사전에는 다른 것 보다 적은 수의 키가 있을 수 있다. 이는 <a class="reference internal" href="dml.html#sqlalchemy.sql.expression.Insert" title="sqlalchemy.sql.expression.Insert"><code class="xref py py-class docutils literal notranslate"><span class="pre">Insert</span></code></a>명령문이 리스트의 <strong>첫번재</strong> 사전에 맞춰 컴파일되면, 나머지 모든 사전들은 이 컴파일 된 구문에 호환된다고 가정한다는 것이다.</p>
<p>&quot;executemany&quot;같은 호출 스타일은 각각 <a class="reference internal" href="dml.html#sqlalchemy.sql.expression.insert" title="sqlalchemy.sql.expression.insert"><code class="xref py py-func docutils literal notranslate"><span class="pre">insert()</span></code></a>, <a class="reference internal" href="dml.html#sqlalchemy.sql.expression.update" title="sqlalchemy.sql.expression.update"><code class="xref py py-func docutils literal notranslate"><span class="pre">update()</span></code></a>, <a class="reference internal" href="dml.html#sqlalchemy.sql.expression.delete" title="sqlalchemy.sql.expression.delete"><code class="xref py py-func docutils literal notranslate"><span class="pre">delete()</span></code></a> 구조에서 사용 가능하다.</p>
</div>
<div class="section" id="selecting">
<span id="coretutorial-selecting"></span><h2>Selecting<a class="headerlink" href="#selecting" title="제목 주소">¶</a></h2>
<p>위의 예제에서 우리는 INSERTS를 했으므로 테스트 데이테베이스는 그 데이터를 가지고 있다.그 데이터에 대한 더 흥미로운 부분은 그것을 selecting 하는것이다. UPDATE와 DELETE 구문은 나중에 다룰 것이다. SELECT 구문을 생성하기 위한 기본 구조는 <a class="reference internal" href="selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> 함수를 사용하는것이다:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy.sql</span> <span class="kn">import</span> <span class="n">select</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span><span class="n">users</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class=" -Sql -Sql-Open">{opensql}</span><span class=" -Sql">SELECT users.id, users.name, users.fullname</span>
<span class=" -Sql">FROM users</span>
<span class=" -Sql">()</span><span class="go"></span>
</pre></div>
</div>
<p>위의 예제에서, 우리는 기본 <a class="reference internal" href="selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a>함수를 호출하여 <code class="docutils literal notranslate"><span class="pre">users</span></code>테이블을select의 COLUMNS 절 내에 놓고 그 다음 그것을 실행했다. SQLAlchemy는 <code class="docutils literal notranslate"><span class="pre">users</span></code> 테이블을 각 컬럼 집합으로 확장하고 FROM 절을 생성했다. 반환된 결과는 DBAPI 커서와 같이 동작하는 <a class="reference internal" href="connections.html#sqlalchemy.engine.ResultProxy" title="sqlalchemy.engine.ResultProxy"><code class="xref py py-class docutils literal notranslate"><span class="pre">ResultProxy</span></code></a>객체이다. 이 객체는 <a class="reference internal" href="connections.html#sqlalchemy.engine.ResultProxy.fetchone" title="sqlalchemy.engine.ResultProxy.fetchone"><code class="xref py py-func docutils literal notranslate"><span class="pre">fetchone()</span></code></a>함수나 <a class="reference internal" href="connections.html#sqlalchemy.engine.ResultProxy.fetchall" title="sqlalchemy.engine.ResultProxy.fetchall"><code class="xref py py-func docutils literal notranslate"><span class="pre">fetchall()</span></code></a>함수를 포함하고 있다.가장 쉽게 행들을 가져오는 방법은 그냥 이터레이팅을 사용하는 것이다.</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
<span class="go">(1, u&#39;jack&#39;, u&#39;Jack Jones&#39;)</span>
<span class="go">(2, u&#39;wendy&#39;, u&#39;Wendy Williams&#39;)</span>
</pre></div>
</div>
<p>위에서, 우리는 각 행을 프린트하면 각 행들의 간단한 튜플 객체 결과가 생성된다.우리는 각 행들의 데이터에 접근할 수 있는 더 많은 옵션들을 가질 수 있다. 가장 일반적인 방법 중 하나는 열의 문자열 이름을 사용하여 사전(dictionary) 액세스를 사용하는 것이다:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class=" -Sql -Sql-Link">{sql}</span><span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class=" -Sql -Sql-Popup">SELECT users.id, users.name, users.fullname</span>
<span class=" -Sql -Sql-Popup">FROM users</span>
<span class=" -Sql -Sql-Popup">()</span>

<span class=" -Sql -Sql-Popup">{stop}</span><span class="gp">&gt;&gt;&gt; </span><span class="n">row</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">fetchone</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="s2">&quot;name:&quot;</span><span class="p">,</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="s2">&quot;; fullname:&quot;</span><span class="p">,</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;fullname&#39;</span><span class="p">])</span>
<span class="go">name: jack ; fullname: Jack Jones</span>
</pre></div>
</div>
<p>정수 인덱스들도 잘 작동한다:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">row</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">fetchone</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="s2">&quot;name:&quot;</span><span class="p">,</span> <span class="n">row</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;; fullname:&quot;</span><span class="p">,</span> <span class="n">row</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="go">name: wendy ; fullname: Wendy Williams</span>
</pre></div>
</div>
<p>나중에 유용하게 쓰일 수 있는 또 다른 방법은, <a class="reference internal" href="metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a>객체를 키로 직접 사용하는 것이다.</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class=" -Sql -Sql-Link">{sql}</span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;name:&quot;</span><span class="p">,</span> <span class="n">row</span><span class="p">[</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">],</span> <span class="s2">&quot;; fullname:&quot;</span><span class="p">,</span> <span class="n">row</span><span class="p">[</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">fullname</span><span class="p">])</span>
<span class=" -Sql -Sql-Popup">SELECT users.id, users.name, users.fullname</span>
<span class=" -Sql -Sql-Popup">FROM users</span>
<span class=" -Sql -Sql-Popup">()</span>
<span class=" -Sql -Sql-Popup">{stop}</span><span class="go">name: jack ; fullname: Jack Jones</span>
<span class="go">name: wendy ; fullname: Wendy Williams</span>
</pre></div>
</div>
<p>보류중인 행이 남아있는 결과 집합은 버리기 전에 명시적으로 닫아야 한다. <a class="reference internal" href="connections.html#sqlalchemy.engine.ResultProxy" title="sqlalchemy.engine.ResultProxy"><code class="xref py py-class docutils literal notranslate"><span class="pre">ResultProxy</span></code></a>객체가 가비지-수집(garbage-collected)될 때해당 객체에서 참조하는 커서 및 커낵션 리소스가 각각 닫히고 커낵션 풀로 리소스들이 반환되지만일부 데이터베이스 API는 이러한 일에 매우 까다로우며 명시적으로 설정하는 것이 좋다:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">result</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>select의 COLUMNS 절에 있는 열을 보다 세심하게 관리하려는 경우 우리는 <a class="reference internal" href="metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>객체로부터 개별적인 <a class="reference internal" href="metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a>객체를 참조한다. 아래의 예제와 같이 이것들은 <a class="reference internal" href="metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>객채의 속성에서 <code class="docutils literal notranslate"><span class="pre">c</span></code>로 명명된 속성으로 사용될 수 있다:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">fullname</span><span class="p">])</span>
<span class=" -Sql -Sql-Link">{sql}</span><span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class=" -Sql -Sql-Popup">SELECT users.name, users.fullname</span>
<span class=" -Sql -Sql-Popup">FROM users</span>
<span class=" -Sql -Sql-Popup">()</span>
<span class=" -Sql -Sql-Popup">{stop}</span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
<span class="go">(u&#39;jack&#39;, u&#39;Jack Jones&#39;)</span>
<span class="go">(u&#39;wendy&#39;, u&#39;Wendy Williams&#39;)</span>
</pre></div>
</div>
<p>FROM 절에 대해 흥미로운 것을 관찰 할 수 있다. 생성된 명령문에는 &quot;SELECT columns&quot;부분과&quot;FROM table&quot;부분의 두 개의 별개 섹션이 있지만, <a class="reference internal" href="selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a>함수 구조는 단지 하나의컬럼 리스트(users)만 가지고 있따. 어떻게 이것이 작동하는가 ? <em>두 개의</em> 테이블들을 <a class="reference internal" href="selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a>구문에 넣어 보자:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class=" -Sql -Sql-Link">{sql}</span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">select</span><span class="p">([</span><span class="n">users</span><span class="p">,</span> <span class="n">addresses</span><span class="p">])):</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
<span class=" -Sql -Sql-Popup">SELECT users.id, users.name, users.fullname, addresses.id, addresses.user_id, addresses.email_address</span>
<span class=" -Sql -Sql-Popup">FROM users, addresses</span>
<span class=" -Sql -Sql-Popup">()</span>
<span class=" -Sql -Sql-Popup">{stop}</span><span class="go">(1, u&#39;jack&#39;, u&#39;Jack Jones&#39;, 1, 1, u&#39;jack@yahoo.com&#39;)</span>
<span class="go">(1, u&#39;jack&#39;, u&#39;Jack Jones&#39;, 2, 1, u&#39;jack@msn.com&#39;)</span>
<span class="go">(1, u&#39;jack&#39;, u&#39;Jack Jones&#39;, 3, 2, u&#39;www@www.org&#39;)</span>
<span class="go">(1, u&#39;jack&#39;, u&#39;Jack Jones&#39;, 4, 2, u&#39;wendy@aol.com&#39;)</span>
<span class="go">(2, u&#39;wendy&#39;, u&#39;Wendy Williams&#39;, 1, 1, u&#39;jack@yahoo.com&#39;)</span>
<span class="go">(2, u&#39;wendy&#39;, u&#39;Wendy Williams&#39;, 2, 1, u&#39;jack@msn.com&#39;)</span>
<span class="go">(2, u&#39;wendy&#39;, u&#39;Wendy Williams&#39;, 3, 2, u&#39;www@www.org&#39;)</span>
<span class="go">(2, u&#39;wendy&#39;, u&#39;Wendy Williams&#39;, 4, 2, u&#39;wendy@aol.com&#39;)</span>
</pre></div>
</div>
<p><strong>두개</strong> 테이블들이 FROM 절에 위치되어 있지만, 이것은 완전히 엉망으로 만들어졌다. SQL 조인(join)에 대해 친숙한 유저들은 이것이 <strong>Cartesian product</strong>인 것을 알것이다. <code class="docutils literal notranslate"><span class="pre">users</span></code>테이블의 각 행들 중 <code class="docutils literal notranslate"><span class="pre">addresses</span></code> 테이블의 각 행들과 대응하는 것들만 생성된다. 그래서 이 구문을 좀 정리해보자면 우리는 WHERE 절이 필요하다. 우리는 이것을 위해:meth:<cite>.Select.where</cite>함수를 사용한다.</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span><span class="n">users</span><span class="p">,</span> <span class="n">addresses</span><span class="p">])</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">user_id</span><span class="p">)</span>
<span class=" -Sql -Sql-Link">{sql}</span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
<span class=" -Sql -Sql-Popup">SELECT users.id, users.name, users.fullname, addresses.id,</span>
<span class=" -Sql -Sql-Popup">   addresses.user_id, addresses.email_address</span>
<span class=" -Sql -Sql-Popup">FROM users, addresses</span>
<span class=" -Sql -Sql-Popup">WHERE users.id = addresses.user_id</span>
<span class=" -Sql -Sql-Popup">()</span>
<span class=" -Sql -Sql-Popup">{stop}</span><span class="go">(1, u&#39;jack&#39;, u&#39;Jack Jones&#39;, 1, 1, u&#39;jack@yahoo.com&#39;)</span>
<span class="go">(1, u&#39;jack&#39;, u&#39;Jack Jones&#39;, 2, 1, u&#39;jack@msn.com&#39;)</span>
<span class="go">(2, u&#39;wendy&#39;, u&#39;Wendy Williams&#39;, 3, 2, u&#39;www@www.org&#39;)</span>
<span class="go">(2, u&#39;wendy&#39;, u&#39;Wendy Williams&#39;, 4, 2, u&#39;wendy@aol.com&#39;)</span>
</pre></div>
</div>
<p>위의 예제는 훨씬 더 정리되어있다. 우리는 <a class="reference internal" href="selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a>함수에 <code class="docutils literal notranslate"><span class="pre">WHERE</span> <span class="pre">users.id</span> <span class="pre">=</span> <span class="pre">addresses.user_id</span></code>를 추가한 것과 똑같은 효과를 갖은 표현식을 추가했다. 그 결과 우리는 <code class="docutils literal notranslate"><span class="pre">users</span></code>와 <code class="docutils literal notranslate"><span class="pre">addresses</span></code>행들의 조인이 의미를 갖도록 만들어졌다. 하지만 이 표현식을 봐보자. 이것은 두 개의 다른 <a class="reference internal" href="metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a>객체 사이에 단지 파이썬 동등 연산자를 사용한다. 뭔가 일어난것은 분명합니다. <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">==</span> <span class="pre">1</span> <span class="pre">``\</span> <span class="pre">은</span> <span class="pre">``True</span></code>를 반환하고 `` 1 == 2``는 <code class="docutils literal notranslate"><span class="pre">False</span></code>를 반환하지만 WHERE 절에선 이렇지 않는다. 아래의 코드를 보고 이게 무슨 의미인지 좀 더 자세히 알아본다:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">user_id</span>
<span class="go">&lt;sqlalchemy.sql.elements.BinaryExpression object at 0x...&gt;</span>
</pre></div>
</div>
<p>와우, 놀랍지않는가 ? 이것은 <code class="docutils literal notranslate"><span class="pre">True</span></code>도 아니고 <code class="docutils literal notranslate"><span class="pre">False</span></code>도 아니다. 도대체 무엇인가 ?</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">str</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">user_id</span><span class="p">)</span>
<span class="go">&#39;users.id = addresses.user_id&#39;</span>
</pre></div>
</div>
<p>위의 코드에서 보이는것처럼 <code class="docutils literal notranslate"><span class="pre">==</span></code>연산자는 <a class="reference internal" href="dml.html#sqlalchemy.sql.expression.Insert" title="sqlalchemy.sql.expression.Insert"><code class="xref py py-class docutils literal notranslate"><span class="pre">Insert</span></code></a>와 우리가 지금까지 만든 <a class="reference internal" href="selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a>객체들과 매우 유사한 객체를 생성한다. 만약 이것을 <code class="docutils literal notranslate"><span class="pre">str()</span></code>로 호출해본다면 그것은 SQL을 생성한다. 이제는 우리가 작업하는 모든 것들이 궁극적으로 같은 유형의 객체라는 것을 알 수 있다. SQLAlchemy는 이 모든 표현식의 기본 클래스를 <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.expression.ColumnElement" title="sqlalchemy.sql.expression.ColumnElement"><code class="xref py py-class docutils literal notranslate"><span class="pre">ColumnElement</span></code></a>로 정의한다.</p>
</div>
<div class="section" id="operators">
<h2>연산자<a class="headerlink" href="#operators" title="제목 주소">¶</a></h2>
<p>SQLAlchemy의 운영 페러다임을 이해했으므로 몇 가지 기능을 살펴보겠다. 우리는 두 열을 서로 동일시(equate) 하는 방법을 보았다:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">user_id</span><span class="p">)</span>
<span class="go">users.id = addresses.user_id</span>
</pre></div>
</div>
<p>만약 리터럴 값(SQLAlchemy 절 객체가 아닌 리터럴 의미)을 사용하면 바인드 매개 변수를 얻을 수 있다:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="mi">7</span><span class="p">)</span>
<span class="go">users.id = :id_1</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">7</span></code>리터럴은 <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.expression.ColumnElement" title="sqlalchemy.sql.expression.ColumnElement"><code class="xref py py-class docutils literal notranslate"><span class="pre">ColumnElement</span></code></a>클래스 안에 결과를 담는다. 우리는 앞전에 <a class="reference internal" href="dml.html#sqlalchemy.sql.expression.Insert" title="sqlalchemy.sql.expression.Insert"><code class="xref py py-class docutils literal notranslate"><span class="pre">Insert</span></code></a>객체에 사용했던 트릭을 사용하여 이 객체를 좀 더 자세히 볼 수 있다.</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="mi">7</span><span class="p">)</span><span class="o">.</span><span class="n">compile</span><span class="p">()</span><span class="o">.</span><span class="n">params</span>
<span class="go">{u&#39;id_1&#39;: 7}</span>
</pre></div>
</div>
<p>대부분의 파이썬연산자, 같음(=), 같지 않음(!=) 등은 SQL 표현식을 생성합니다.</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span> <span class="o">!=</span> <span class="mi">7</span><span class="p">)</span>
<span class="go">users.id != :id_1</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># None converts to IS NULL</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="bp">None</span><span class="p">)</span>
<span class="go">users.name IS NULL</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># reverse works too</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="s1">&#39;fred&#39;</span> <span class="o">&gt;</span> <span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
<span class="go">users.name &lt; :name_1</span>
</pre></div>
</div>
<p>정수 열 두개를 더하면 더하기 식이 된다.</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span> <span class="o">+</span> <span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
<span class="go">users.id + addresses.id</span>
</pre></div>
</div>
<p>흥미롭게도, <a class="reference internal" href="metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a>의 타입이 중요하다.우리가 <code class="docutils literal notranslate"><span class="pre">+</span></code>를 문자열 기반 컬럼(<a class="reference internal" href="metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a>객체가 시작될 때 <a class="reference internal" href="type_basics.html#sqlalchemy.types.Integer" title="sqlalchemy.types.Integer"><code class="xref py py-class docutils literal notranslate"><span class="pre">Integer</span></code></a>이나 <a class="reference internal" href="type_basics.html#sqlalchemy.types.String" title="sqlalchemy.types.String"><code class="xref py py-class docutils literal notranslate"><span class="pre">String</span></code></a>타입을 넣었던 것을 생각해보라)에 사용한다면 좀 다른 결과를 얻는다:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">fullname</span><span class="p">)</span>
<span class="go">users.name || users.fullname</span>
</pre></div>
</div>
<p>Where <code class="docutils literal notranslate"><span class="pre">||</span></code> is the string concatenation operator used on most databases. But
not all of them. MySQL users, fear not:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">((</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">fullname</span><span class="p">)</span><span class="o">.</span>
<span class="gp">... </span>     <span class="nb">compile</span><span class="p">(</span><span class="n">bind</span><span class="o">=</span><span class="n">create_engine</span><span class="p">(</span><span class="s1">&#39;mysql://&#39;</span><span class="p">)))</span> <span class="c1"># doctest: +SKIP</span>
<span class="go">concat(users.name, users.fullname)</span>
</pre></div>
</div>
<p>위의 코드는 MySQL 데이터베이스와 연결된 <a class="reference internal" href="connections.html#sqlalchemy.engine.Engine" title="sqlalchemy.engine.Engine"><code class="xref py py-class docutils literal notranslate"><span class="pre">Engine</span></code></a>객체로부터 생성된 SQL 을 보여준다. <code class="docutils literal notranslate"><span class="pre">||</span></code>연산자는 MySQL의 <code class="docutils literal notranslate"><span class="pre">concat()</span></code> 함수로 컴파일된다.</p>
<p>만약 사용할 수 없는 연산자를 만나게 된다면 <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.Operators.op" title="sqlalchemy.sql.operators.Operators.op"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Operators.op()</span></code></a>함수를 사용한다.이것은 어떤 연산자라도 너가 필요한 연산자를 생성한다.</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">op</span><span class="p">(</span><span class="s1">&#39;tiddlywinks&#39;</span><span class="p">)(</span><span class="s1">&#39;foo&#39;</span><span class="p">))</span>
<span class="go">users.name tiddlywinks :name_1</span>
</pre></div>
</div>
<p>또한 이 함수는 비트 연산자를 명시적으로 만들때 사용할 수 있다:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">somecolumn</span><span class="o">.</span><span class="n">op</span><span class="p">(</span><span class="s1">&#39;&amp;&#39;</span><span class="p">)(</span><span class="mh">0xff</span><span class="p">)</span>
</pre></div>
</div>
<p>위의 예제는 <code class="docutils literal notranslate"><span class="pre">somecolumn</span></code>안에 있는 값의 비트의 AND 연산이다.</p>
<p>When using <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.Operators.op" title="sqlalchemy.sql.operators.Operators.op"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Operators.op()</span></code></a>, the return type of the expression may be important,
especially when the operator is used in an expression that will be sent as a result
column.   For this case, be sure to make the type explicit, if not what's
normally expected, using <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.expression.type_coerce" title="sqlalchemy.sql.expression.type_coerce"><code class="xref py py-func docutils literal notranslate"><span class="pre">type_coerce()</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">type_coerce</span>
<span class="n">expr</span> <span class="o">=</span> <span class="n">type_coerce</span><span class="p">(</span><span class="n">somecolumn</span><span class="o">.</span><span class="n">op</span><span class="p">(</span><span class="s1">&#39;-%&gt;&#39;</span><span class="p">)(</span><span class="s1">&#39;foo&#39;</span><span class="p">),</span> <span class="n">MySpecialType</span><span class="p">())</span>
<span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span><span class="n">expr</span><span class="p">])</span>
</pre></div>
</div>
<p>부울 연산자의 경우 <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.Operators.bool_op" title="sqlalchemy.sql.operators.Operators.bool_op"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Operators.bool_op()</span></code></a>를 사용하여 표현식의 반환 타입이 부울로 처리되도록 한다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">somecolumn</span><span class="o">.</span><span class="n">bool_op</span><span class="p">(</span><span class="s1">&#39;--&gt;&#39;</span><span class="p">)(</span><span class="s1">&#39;some value&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">버전 1.2.0b3에 추가: </span><a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.Operators.bool_op" title="sqlalchemy.sql.operators.Operators.bool_op"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Operators.bool_op()</span></code></a>함수를 추가함.</p>
</div>
<div class="section" id="operator-customization">
<h3>커스텀 연산자<a class="headerlink" href="#operator-customization" title="제목 주소">¶</a></h3>
<p><a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.Operators.op" title="sqlalchemy.sql.operators.Operators.op"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Operators.op()</span></code></a>은 급하게 커스텀 연산자를 사용할때 편하지만 코어는 타입 수준(type level)에서 연산자 시스템의 기본적인 사용자 정의 및 확장을 지원한다. 기존 연산자의 동작은 타입별로 수정할 수 있으며 특정 유형의 일부인 모든 컬럼 표현식에서 사용할 수 있는 새로운 연산자를 정의할 수 있다. 더 자세한 내용은 <a class="reference internal" href="custom_types.html#types-operators"><span class="std std-ref">Redefining and Creating New Operators</span></a>절을 참조하십시오.</p>
</div>
</div>
<div class="section" id="conjunctions">
<h2>연결 함수(Conjunctions)<a class="headerlink" href="#conjunctions" title="제목 주소">¶</a></h2>
<p>우리는 연산자의 일부를 <a class="reference internal" href="selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a>함수 내에서 보이고 싶을 상황이 있다.그러나 우리는 이것들을 좀 더 덩어리로 묶을 필요가 있다. 그래서 먼저 몇가지 conjunctions을소개한다. conjunctions은 AND와 OR처럼 무언가를 묶는 작은 단어이다. <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.expression.and_" title="sqlalchemy.sql.expression.and_"><code class="xref py py-func docutils literal notranslate"><span class="pre">and_()</span></code></a>, <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.expression.or_" title="sqlalchemy.sql.expression.or_"><code class="xref py py-func docutils literal notranslate"><span class="pre">or_()</span></code></a>, <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.expression.not_" title="sqlalchemy.sql.expression.not_"><code class="xref py py-func docutils literal notranslate"><span class="pre">not_()</span></code></a>함수는 SQLAlchemy에서 제공하는 함수들과 상응하여 동작한다. (또한 <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.like" title="sqlalchemy.sql.operators.ColumnOperators.like"><code class="xref py py-meth docutils literal notranslate"><span class="pre">like()</span></code></a>도 가능하다.)</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy.sql</span> <span class="kn">import</span> <span class="n">and_</span><span class="p">,</span> <span class="n">or_</span><span class="p">,</span> <span class="n">not_</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">and_</span><span class="p">(</span>
<span class="gp">... </span>        <span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">like</span><span class="p">(</span><span class="s1">&#39;j%&#39;</span><span class="p">),</span>
<span class="gp">... </span>        <span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">user_id</span><span class="p">,</span>
<span class="gp">... </span>        <span class="n">or_</span><span class="p">(</span>
<span class="gp">... </span>             <span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">email_address</span> <span class="o">==</span> <span class="s1">&#39;wendy@aol.com&#39;</span><span class="p">,</span>
<span class="gp">... </span>             <span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">email_address</span> <span class="o">==</span> <span class="s1">&#39;jack@yahoo.com&#39;</span>
<span class="gp">... </span>        <span class="p">),</span>
<span class="gp">... </span>        <span class="n">not_</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">... </span>      <span class="p">)</span>
<span class="gp">... </span> <span class="p">)</span>
<span class="go">users.name LIKE :name_1 AND users.id = addresses.user_id AND</span>
<span class="go">(addresses.email_address = :email_address_1</span>
<span class="go">   OR addresses.email_address = :email_address_2)</span>
<span class="go">AND users.id &lt;= :id_1</span>
</pre></div>
</div>
<p>그리고 앞서 설명했던 bitwise AND, OR, NOT 연산자를 사용할 수 있다. 하지만 파이썬 연산자 우선 순위 때문에 괄호를 잘 고려해야한다.</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">like</span><span class="p">(</span><span class="s1">&#39;j%&#39;</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">user_id</span><span class="p">)</span> <span class="o">&amp;</span>
<span class="gp">... </span>    <span class="p">(</span>
<span class="gp">... </span>      <span class="p">(</span><span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">email_address</span> <span class="o">==</span> <span class="s1">&#39;wendy@aol.com&#39;</span><span class="p">)</span> <span class="o">|</span> \
<span class="gp">... </span>      <span class="p">(</span><span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">email_address</span> <span class="o">==</span> <span class="s1">&#39;jack@yahoo.com&#39;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="p">)</span> \
<span class="gp">... </span>    <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="o">&gt;</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">users.name LIKE :name_1 AND users.id = addresses.user_id AND</span>
<span class="go">(addresses.email_address = :email_address_1</span>
<span class="go">    OR addresses.email_address = :email_address_2)</span>
<span class="go">AND users.id &lt;= :id_1</span>
</pre></div>
</div>
<p>이러한 연산자를 이용해 AOL, MSN 이메일 주소를 갖은 모든 사용자를 selecting 해본다.이 사용자의 이름은 &quot;m&quot; 과 &quot;z&quot; 사이의 문자로 시작하며, 풀 네임과 주소를 이메일 주소를 포함하는 컬럼을 생성한다. <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.between" title="sqlalchemy.sql.operators.ColumnOperators.between"><code class="xref py py-meth docutils literal notranslate"><span class="pre">between()</span></code></a>와 <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.expression.ColumnElement.label" title="sqlalchemy.sql.expression.ColumnElement.label"><code class="xref py py-meth docutils literal notranslate"><span class="pre">label()</span></code></a>이 두개의 새로운 구조를 구문에 추가한다. <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.between" title="sqlalchemy.sql.operators.ColumnOperators.between"><code class="xref py py-meth docutils literal notranslate"><span class="pre">between()</span></code></a>은 BETWEEN 절을 생성하고, <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.expression.ColumnElement.label" title="sqlalchemy.sql.expression.ColumnElement.label"><code class="xref py py-meth docutils literal notranslate"><span class="pre">label()</span></code></a>은 <code class="docutils literal notranslate"><span class="pre">AS</span></code>키워드를 사용하는 레이블들을 생성하는 컬럼 표현식에 사용된다. <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.expression.ColumnElement.label" title="sqlalchemy.sql.expression.ColumnElement.label"><code class="xref py py-meth docutils literal notranslate"><span class="pre">label()</span></code></a>는 이름이 없는 표현식에서 selecting 할때 권장된다.</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">select</span><span class="p">([(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">fullname</span> <span class="o">+</span>
<span class="gp">... </span>              <span class="s2">&quot;, &quot;</span> <span class="o">+</span> <span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">email_address</span><span class="p">)</span><span class="o">.</span>
<span class="gp">... </span>               <span class="n">label</span><span class="p">(</span><span class="s1">&#39;title&#39;</span><span class="p">)])</span><span class="o">.</span>\
<span class="gp">... </span>       <span class="n">where</span><span class="p">(</span>
<span class="gp">... </span>          <span class="n">and_</span><span class="p">(</span>
<span class="gp">... </span>              <span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">user_id</span><span class="p">,</span>
<span class="gp">... </span>              <span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">between</span><span class="p">(</span><span class="s1">&#39;m&#39;</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">),</span>
<span class="gp">... </span>              <span class="n">or_</span><span class="p">(</span>
<span class="gp">... </span>                 <span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">email_address</span><span class="o">.</span><span class="n">like</span><span class="p">(</span><span class="s1">&#39;%@aol.com&#39;</span><span class="p">),</span>
<span class="gp">... </span>                 <span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">email_address</span><span class="o">.</span><span class="n">like</span><span class="p">(</span><span class="s1">&#39;%@msn.com&#39;</span><span class="p">)</span>
<span class="gp">... </span>              <span class="p">)</span>
<span class="gp">... </span>          <span class="p">)</span>
<span class="gp">... </span>       <span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>
<span class="go">SELECT users.fullname || ? || addresses.email_address AS title</span>
<span class="go">FROM users, addresses</span>
<span class="go">WHERE users.id = addresses.user_id AND users.name BETWEEN ? AND ? AND</span>
<span class="go">(addresses.email_address LIKE ? OR addresses.email_address LIKE ?)</span>
<span class="go">(&#39;, &#39;, &#39;m&#39;, &#39;z&#39;, &#39;%@aol.com&#39;, &#39;%@msn.com&#39;)</span>
<span class="go">[(u&#39;Wendy Williams, wendy@aol.com&#39;,)]</span>
</pre></div>
</div>
<p>SQLAlchemy를 통해 위 구문의 FROM 절을 본다면, 사실 내부적으론 비트 연산을 통해 FROM 절을 결정한다.이 밖에도 컬럼 절, WHERE 절, ORDER BY, GROUP BY, HAVING 등 아직 다루지 않은 요소들이 있다.</p>
<p><a class="reference internal" href="sqlelement.html#sqlalchemy.sql.expression.and_" title="sqlalchemy.sql.expression.and_"><code class="xref py py-func docutils literal notranslate"><span class="pre">and_()</span></code></a>함수를 사용하는 지름길은 여러 <a class="reference internal" href="selectable.html#sqlalchemy.sql.expression.Select.where" title="sqlalchemy.sql.expression.Select.where"><code class="xref py py-meth docutils literal notranslate"><span class="pre">where()</span></code></a>절을 함께 연결 하는 것이다. 위의 내용을 다음과 같이 작성할 수도 있다.</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">select</span><span class="p">([(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">fullname</span> <span class="o">+</span>
<span class="gp">... </span>              <span class="s2">&quot;, &quot;</span> <span class="o">+</span> <span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">email_address</span><span class="p">)</span><span class="o">.</span>
<span class="gp">... </span>               <span class="n">label</span><span class="p">(</span><span class="s1">&#39;title&#39;</span><span class="p">)])</span><span class="o">.</span>\
<span class="gp">... </span>       <span class="n">where</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">user_id</span><span class="p">)</span><span class="o">.</span>\
<span class="gp">... </span>       <span class="n">where</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">between</span><span class="p">(</span><span class="s1">&#39;m&#39;</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">))</span><span class="o">.</span>\
<span class="gp">... </span>       <span class="n">where</span><span class="p">(</span>
<span class="gp">... </span>              <span class="n">or_</span><span class="p">(</span>
<span class="gp">... </span>                 <span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">email_address</span><span class="o">.</span><span class="n">like</span><span class="p">(</span><span class="s1">&#39;%@aol.com&#39;</span><span class="p">),</span>
<span class="gp">... </span>                 <span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">email_address</span><span class="o">.</span><span class="n">like</span><span class="p">(</span><span class="s1">&#39;%@msn.com&#39;</span><span class="p">)</span>
<span class="gp">... </span>              <span class="p">)</span>
<span class="gp">... </span>       <span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>
<span class="go">SELECT users.fullname || ? || addresses.email_address AS title</span>
<span class="go">FROM users, addresses</span>
<span class="go">WHERE users.id = addresses.user_id AND users.name BETWEEN ? AND ? AND</span>
<span class="go">(addresses.email_address LIKE ? OR addresses.email_address LIKE ?)</span>
<span class="go">(&#39;, &#39;, &#39;m&#39;, &#39;z&#39;, &#39;%@aol.com&#39;, &#39;%@msn.com&#39;)</span>
<span class="go">[(u&#39;Wendy Williams, wendy@aol.com&#39;,)]</span>
</pre></div>
</div>
<p><a class="reference internal" href="selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a>의 연속적인 메소드 호출을 통해 생성자를 구축 할 수 있는 방법을:term:<cite>method chaining</cite>이라고 한다.</p>
</div>
<div class="section" id="using-textual-sql">
<span id="sqlexpression-text"></span><h2>텍스트 SQL 사용<a class="headerlink" href="#using-textual-sql" title="제목 주소">¶</a></h2>
<p>우리의 마지막 예제는 정말 타이핑 하기 힘든 예제가 되었다. 텍스트 SQL 표현에서 마지막 예제처럼 컴포넌트들이 프로그래밍(programmatic) 방식으로 그룹화된 파이썬 구조는 이해되기 쉽지 않다. 그래서 SQLAlchemy를 사용하면 SQL이 이미 알려져 있고 거기에 동적 기능을 지원하는 구문이 강력하게 필요하지 않는 경우문자열(텍스트 SQL)을 사용할 수 있다.:func:<cite>~.expression.text</cite>구조는 대부분 변경되지 않는 데이터베이스에 전달되는 텍스트 문을 작성하는데 사용된다. 아래 예제에서는 <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.expression.text" title="sqlalchemy.sql.expression.text"><code class="xref py py-func docutils literal notranslate"><span class="pre">text()</span></code></a>객체를 만들고 실행한다.</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy.sql</span> <span class="kn">import</span> <span class="n">text</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">text</span><span class="p">(</span>
<span class="gp">... </span>    <span class="s2">&quot;SELECT users.fullname || &#39;, &#39; || addresses.email_address AS title &quot;</span>
<span class="gp">... </span>        <span class="s2">&quot;FROM users, addresses &quot;</span>
<span class="gp">... </span>        <span class="s2">&quot;WHERE users.id = addresses.user_id &quot;</span>
<span class="gp">... </span>        <span class="s2">&quot;AND users.name BETWEEN :x AND :y &quot;</span>
<span class="gp">... </span>        <span class="s2">&quot;AND (addresses.email_address LIKE :e1 &quot;</span>
<span class="gp">... </span>            <span class="s2">&quot;OR addresses.email_address LIKE :e2)&quot;</span><span class="p">)</span>
<span class=" -Sql -Sql-Link">{sql}</span><span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="s1">&#39;z&#39;</span><span class="p">,</span> <span class="n">e1</span><span class="o">=</span><span class="s1">&#39;%@aol.com&#39;</span><span class="p">,</span> <span class="n">e2</span><span class="o">=</span><span class="s1">&#39;%@msn.com&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>
<span class=" -Sql -Sql-Popup">SELECT users.fullname || &#39;, &#39; || addresses.email_address AS title</span>
<span class=" -Sql -Sql-Popup">FROM users, addresses</span>
<span class=" -Sql -Sql-Popup">WHERE users.id = addresses.user_id AND users.name BETWEEN ? AND ? AND</span>
<span class=" -Sql -Sql-Popup">(addresses.email_address LIKE ? OR addresses.email_address LIKE ?)</span>
<span class=" -Sql -Sql-Popup">(&#39;m&#39;, &#39;z&#39;, &#39;%@aol.com&#39;, &#39;%@msn.com&#39;)</span>
<span class=" -Sql -Sql-Popup">{stop}</span><span class="go">[(u&#39;Wendy Williams, wendy@aol.com&#39;,)]</span>
</pre></div>
</div>
<p>위의 예제에서 <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.expression.text" title="sqlalchemy.sql.expression.text"><code class="xref py py-func docutils literal notranslate"><span class="pre">text()</span></code></a>안에 콜론 포맷을 사용하여 바운드 파라미터들이 지정 되었음을 알 수 있다. 이 형식은 데이터베이스 백엔드와 상관 없이 일관됩니다. 매개 변수에 값을 보낼려면 <a class="reference internal" href="connections.html#sqlalchemy.engine.Connection.execute" title="sqlalchemy.engine.Connection.execute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">execute()</span></code></a>함수에 추가적인 인자를 전달한다.</p>
<div class="section" id="specifying-bound-parameter-behaviors">
<h3>바운드 매개 변수 동작 지정<a class="headerlink" href="#specifying-bound-parameter-behaviors" title="제목 주소">¶</a></h3>
<p><a class="reference internal" href="sqlelement.html#sqlalchemy.sql.expression.text" title="sqlalchemy.sql.expression.text"><code class="xref py py-func docutils literal notranslate"><span class="pre">text()</span></code></a>구조는 <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.expression.TextClause.bindparams" title="sqlalchemy.sql.expression.TextClause.bindparams"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TextClause.bindparams()</span></code></a>메소드를 사용하여 사전-설정된 바운드 값을 지원한다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">stmt</span> <span class="o">=</span> <span class="n">text</span><span class="p">(</span><span class="s2">&quot;SELECT * FROM users WHERE users.name BETWEEN :x AND :y&quot;</span><span class="p">)</span>
<span class="n">stmt</span> <span class="o">=</span> <span class="n">stmt</span><span class="o">.</span><span class="n">bindparams</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="s2">&quot;m&quot;</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="s2">&quot;z&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>매개 변수는 명시적으로 입력 할 수 있다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">stmt</span> <span class="o">=</span> <span class="n">stmt</span><span class="o">.</span><span class="n">bindparams</span><span class="p">(</span><span class="n">bindparam</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">type_</span><span class="o">=</span><span class="n">String</span><span class="p">),</span> <span class="n">bindparam</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">type_</span><span class="o">=</span><span class="n">String</span><span class="p">))</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="s2">&quot;m&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">:</span> <span class="s2">&quot;z&quot;</span><span class="p">})</span>
</pre></div>
</div>
<p>datatype에 의해 제공되어지는 파이선 측 연산이나 특수한 SQL 측 연산을 할때는 타입이 요구된다. 이때 바운드 파라미터를 입력해야한다.</p>
<div class="admonition seealso">
<p class="first admonition-title">더 보기</p>
<p class="last"><a class="reference internal" href="sqlelement.html#sqlalchemy.sql.expression.TextClause.bindparams" title="sqlalchemy.sql.expression.TextClause.bindparams"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TextClause.bindparams()</span></code></a> - 전체 메소드 설명</p>
</div>
</div>
<div class="section" id="specifying-result-column-behaviors">
<span id="sqlexpression-text-columns"></span><h3>결과-컬럼 동작 지정<a class="headerlink" href="#specifying-result-column-behaviors" title="제목 주소">¶</a></h3>
<p><a class="reference internal" href="sqlelement.html#sqlalchemy.sql.expression.TextClause.columns" title="sqlalchemy.sql.expression.TextClause.columns"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TextClause.columns()</span></code></a>메소드를 사용하여 결과 컬럼에 대한 정보를 지정할 수 있다. 이 메소드는 컬럼의 이름에 따라 반환 타입을 지정하는데 사용할 수 있다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">stmt</span> <span class="o">=</span> <span class="n">stmt</span><span class="o">.</span><span class="n">columns</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="n">Integer</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">String</span><span class="p">)</span>
</pre></div>
</div>
<p>또는 타입이 지정되거나 지정되지 않은 위치에 전체 컬럼 표현식을 전달할 수 있다. 이 경우 텍스트 SQL 내에서 명시적으로 컬럼을 나열하는 것이 좋다. 왜냐하면 컬럼 표현식과 SQL의 상관 관계가 위치로(positionally) 수행되어질 것이기 때문이다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">stmt</span> <span class="o">=</span> <span class="n">text</span><span class="p">(</span><span class="s2">&quot;SELECT id, name FROM users&quot;</span><span class="p">)</span>
<span class="n">stmt</span> <span class="o">=</span> <span class="n">stmt</span><span class="o">.</span><span class="n">columns</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
</pre></div>
</div>
<p>When we call the <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.expression.TextClause.columns" title="sqlalchemy.sql.expression.TextClause.columns"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TextClause.columns()</span></code></a> method, we get back a
<a class="reference internal" href="selectable.html#sqlalchemy.sql.expression.TextAsFrom" title="sqlalchemy.sql.expression.TextAsFrom"><code class="xref py py-class docutils literal notranslate"><span class="pre">TextAsFrom</span></code></a> object that supports the full suite of
<a class="reference internal" href="selectable.html#sqlalchemy.sql.expression.TextAsFrom.c" title="sqlalchemy.sql.expression.TextAsFrom.c"><code class="xref py py-attr docutils literal notranslate"><span class="pre">TextAsFrom.c</span></code></a> and other &quot;selectable&quot; operations:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">j</span> <span class="o">=</span> <span class="n">stmt</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">addresses</span><span class="p">,</span> <span class="n">stmt</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">user_id</span><span class="p">)</span>

<span class="n">new_stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span><span class="n">stmt</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">])</span><span class="o">.</span>\
    <span class="n">select_from</span><span class="p">(</span><span class="n">j</span><span class="p">)</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;x&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The positional form of <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.expression.TextClause.columns" title="sqlalchemy.sql.expression.TextClause.columns"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TextClause.columns()</span></code></a> is particularly useful
when relating textual SQL to existing Core or ORM models, because we can use
column expressions directly without worrying about name conflicts or other issues with the
result column names in the textual SQL:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="n">text</span><span class="p">(</span><span class="s2">&quot;SELECT users.id, addresses.id, users.id, &quot;</span>
<span class="gp">... </span>    <span class="s2">&quot;users.name, addresses.email_address AS email &quot;</span>
<span class="gp">... </span>    <span class="s2">&quot;FROM users JOIN addresses ON users.id=addresses.user_id &quot;</span>
<span class="gp">... </span>    <span class="s2">&quot;WHERE users.id = 1&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">columns</span><span class="p">(</span>
<span class="gp">... </span>       <span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">,</span>
<span class="gp">... </span>       <span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">,</span>
<span class="gp">... </span>       <span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">user_id</span><span class="p">,</span>
<span class="gp">... </span>       <span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
<span class="gp">... </span>       <span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">email_address</span>
<span class="gp">... </span>    <span class="p">)</span>
<span class=" -Sql -Sql-Link">{sql}</span><span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span>
<span class=" -Sql -Sql-Popup">SELECT users.id, addresses.id, users.id, users.name,</span>
<span class=" -Sql -Sql-Popup">    addresses.email_address AS email</span>
<span class=" -Sql -Sql-Popup">FROM users JOIN addresses ON users.id=addresses.user_id WHERE users.id = 1</span>
<span class=" -Sql -Sql-Popup">()</span>
<span class=" -Sql -Sql-Popup">{stop}</span>
</pre></div>
</div>
<p>Above, there's three columns in the result that are named &quot;id&quot;, but since
we've associated these with column expressions positionally, the names aren't an issue
when the result-columns are fetched using the actual column object as a key.
Fetching the <code class="docutils literal notranslate"><span class="pre">email_address</span></code> column would be:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">row</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">fetchone</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">row</span><span class="p">[</span><span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">email_address</span><span class="p">]</span>
<span class="go">&#39;jack@yahoo.com&#39;</span>
</pre></div>
</div>
<p>If on the other hand we used a string column key, the usual rules of name-
based matching still apply, and we'd get an ambiguous column error for
the <code class="docutils literal notranslate"><span class="pre">id</span></code> value:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">InvalidRequestError</span>: <span class="n">Ambiguous column name &#39;id&#39; in result set column descriptions</span>
</pre></div>
</div>
<p>It's important to note that while accessing columns from a result set using
<a class="reference internal" href="metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a> objects may seem unusual, it is in fact the only system
used by the ORM, which occurs transparently beneath the facade of the
<a class="reference internal" href="../orm/query.html#sqlalchemy.orm.query.Query" title="sqlalchemy.orm.query.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a> object; in this way, the <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.expression.TextClause.columns" title="sqlalchemy.sql.expression.TextClause.columns"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TextClause.columns()</span></code></a> method
is typically very applicable to textual statements to be used in an ORM
context.   The example at <a class="reference internal" href="../orm/tutorial.html#orm-tutorial-literal-sql"><span class="std std-ref">텍스트형 SQL 사용</span></a> illustrates
a simple usage.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 1.1에 추가: </span>The <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.expression.TextClause.columns" title="sqlalchemy.sql.expression.TextClause.columns"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TextClause.columns()</span></code></a> method now accepts column expressions
which will be matched positionally to a plain text SQL result set,
eliminating the need for column names to match or even be unique in the
SQL statement when matching table metadata or ORM models to textual SQL.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">더 보기</p>
<p><a class="reference internal" href="sqlelement.html#sqlalchemy.sql.expression.TextClause.columns" title="sqlalchemy.sql.expression.TextClause.columns"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TextClause.columns()</span></code></a> - full method description</p>
<p class="last"><a class="reference internal" href="../orm/tutorial.html#orm-tutorial-literal-sql"><span class="std std-ref">텍스트형 SQL 사용</span></a> - integrating ORM-level queries with
<a class="reference internal" href="sqlelement.html#sqlalchemy.sql.expression.text" title="sqlalchemy.sql.expression.text"><code class="xref py py-func docutils literal notranslate"><span class="pre">text()</span></code></a></p>
</div>
</div>
<div class="section" id="using-text-fragments-inside-bigger-statements">
<h3>Using text() fragments inside bigger statements<a class="headerlink" href="#using-text-fragments-inside-bigger-statements" title="제목 주소">¶</a></h3>
<p><a class="reference internal" href="sqlelement.html#sqlalchemy.sql.expression.text" title="sqlalchemy.sql.expression.text"><code class="xref py py-func docutils literal notranslate"><span class="pre">text()</span></code></a> can also be used to produce fragments of SQL
that can be freely within a
<a class="reference internal" href="selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> object, which accepts <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.expression.text" title="sqlalchemy.sql.expression.text"><code class="xref py py-func docutils literal notranslate"><span class="pre">text()</span></code></a>
objects as an argument for most of its builder functions.
Below, we combine the usage of <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.expression.text" title="sqlalchemy.sql.expression.text"><code class="xref py py-func docutils literal notranslate"><span class="pre">text()</span></code></a> within a
<a class="reference internal" href="selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> object.  The <a class="reference internal" href="selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> construct provides the &quot;geometry&quot;
of the statement, and the <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.expression.text" title="sqlalchemy.sql.expression.text"><code class="xref py py-func docutils literal notranslate"><span class="pre">text()</span></code></a> construct provides the
textual content within this form.  We can build a statement without the
need to refer to any pre-established <a class="reference internal" href="metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> metadata:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span>
<span class="gp">... </span>       <span class="n">text</span><span class="p">(</span><span class="s2">&quot;users.fullname || &#39;, &#39; || addresses.email_address AS title&quot;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="p">])</span><span class="o">.</span>\
<span class="gp">... </span>        <span class="n">where</span><span class="p">(</span>
<span class="gp">... </span>            <span class="n">and_</span><span class="p">(</span>
<span class="gp">... </span>                <span class="n">text</span><span class="p">(</span><span class="s2">&quot;users.id = addresses.user_id&quot;</span><span class="p">),</span>
<span class="gp">... </span>                <span class="n">text</span><span class="p">(</span><span class="s2">&quot;users.name BETWEEN &#39;m&#39; AND &#39;z&#39;&quot;</span><span class="p">),</span>
<span class="gp">... </span>                <span class="n">text</span><span class="p">(</span>
<span class="gp">... </span>                    <span class="s2">&quot;(addresses.email_address LIKE :x &quot;</span>
<span class="gp">... </span>                    <span class="s2">&quot;OR addresses.email_address LIKE :y)&quot;</span><span class="p">)</span>
<span class="gp">... </span>            <span class="p">)</span>
<span class="gp">... </span>        <span class="p">)</span><span class="o">.</span><span class="n">select_from</span><span class="p">(</span><span class="n">text</span><span class="p">(</span><span class="s1">&#39;users, addresses&#39;</span><span class="p">))</span>
<span class=" -Sql -Sql-Link">{sql}</span><span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="s1">&#39;%@aol.com&#39;</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="s1">&#39;%@msn.com&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>
<span class=" -Sql -Sql-Popup">SELECT users.fullname || &#39;, &#39; || addresses.email_address AS title</span>
<span class=" -Sql -Sql-Popup">FROM users, addresses</span>
<span class=" -Sql -Sql-Popup">WHERE users.id = addresses.user_id AND users.name BETWEEN &#39;m&#39; AND &#39;z&#39;</span>
<span class=" -Sql -Sql-Popup">AND (addresses.email_address LIKE ? OR addresses.email_address LIKE ?)</span>
<span class=" -Sql -Sql-Popup">(&#39;%@aol.com&#39;, &#39;%@msn.com&#39;)</span>
<span class=" -Sql -Sql-Popup">{stop}</span><span class="go">[(u&#39;Wendy Williams, wendy@aol.com&#39;,)]</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 1.0.0으로 변경: </span>The <a class="reference internal" href="selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> construct emits warnings when string SQL
fragments are coerced to <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.expression.text" title="sqlalchemy.sql.expression.text"><code class="xref py py-func docutils literal notranslate"><span class="pre">text()</span></code></a>, and <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.expression.text" title="sqlalchemy.sql.expression.text"><code class="xref py py-func docutils literal notranslate"><span class="pre">text()</span></code></a> should
be used explicitly.  See <a class="reference internal" href="../changelog/migration_10.html#migration-2992"><span class="std std-ref">Warnings emitted when coercing full SQL fragments into text()</span></a> for background.</p>
</div>
</div>
<div class="section" id="using-more-specific-text-with-table-literal-column-and-column">
<span id="sqlexpression-literal-column"></span><h3>Using More Specific Text with <a class="reference internal" href="selectable.html#sqlalchemy.sql.expression.table" title="sqlalchemy.sql.expression.table"><code class="xref py py-func docutils literal notranslate"><span class="pre">table()</span></code></a>, <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.expression.literal_column" title="sqlalchemy.sql.expression.literal_column"><code class="xref py py-func docutils literal notranslate"><span class="pre">literal_column()</span></code></a>, and <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.expression.column" title="sqlalchemy.sql.expression.column"><code class="xref py py-func docutils literal notranslate"><span class="pre">column()</span></code></a><a class="headerlink" href="#using-more-specific-text-with-table-literal-column-and-column" title="제목 주소">¶</a></h3>
<p>We can move our level of structure back in the other direction too,
by using <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.expression.column" title="sqlalchemy.sql.expression.column"><code class="xref py py-func docutils literal notranslate"><span class="pre">column()</span></code></a>, <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.expression.literal_column" title="sqlalchemy.sql.expression.literal_column"><code class="xref py py-func docutils literal notranslate"><span class="pre">literal_column()</span></code></a>,
and <a class="reference internal" href="selectable.html#sqlalchemy.sql.expression.table" title="sqlalchemy.sql.expression.table"><code class="xref py py-func docutils literal notranslate"><span class="pre">table()</span></code></a> for some of the
key elements of our statement.   Using these constructs, we can get
some more expression capabilities than if we used <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.expression.text" title="sqlalchemy.sql.expression.text"><code class="xref py py-func docutils literal notranslate"><span class="pre">text()</span></code></a>
directly, as they provide to the Core more information about how the strings
they store are to be used, but still without the need to get into full
<a class="reference internal" href="metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> based metadata.  Below, we also specify the <a class="reference internal" href="type_basics.html#sqlalchemy.types.String" title="sqlalchemy.types.String"><code class="xref py py-class docutils literal notranslate"><span class="pre">String</span></code></a>
datatype for two of the key <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.expression.literal_column" title="sqlalchemy.sql.expression.literal_column"><code class="xref py py-func docutils literal notranslate"><span class="pre">literal_column()</span></code></a> objects,
so that the string-specific concatenation operator becomes available.
We also use <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.expression.literal_column" title="sqlalchemy.sql.expression.literal_column"><code class="xref py py-func docutils literal notranslate"><span class="pre">literal_column()</span></code></a> in order to use table-qualified
expressions, e.g. <code class="docutils literal notranslate"><span class="pre">users.fullname</span></code>, that will be rendered as is;
using <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.expression.column" title="sqlalchemy.sql.expression.column"><code class="xref py py-func docutils literal notranslate"><span class="pre">column()</span></code></a> implies an individual column name that may
be quoted:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">select</span><span class="p">,</span> <span class="n">and_</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">String</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy.sql</span> <span class="kn">import</span> <span class="n">table</span><span class="p">,</span> <span class="n">literal_column</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span>
<span class="gp">... </span>   <span class="n">literal_column</span><span class="p">(</span><span class="s2">&quot;users.fullname&quot;</span><span class="p">,</span> <span class="n">String</span><span class="p">)</span> <span class="o">+</span>
<span class="gp">... </span>   <span class="s1">&#39;, &#39;</span> <span class="o">+</span>
<span class="gp">... </span>   <span class="n">literal_column</span><span class="p">(</span><span class="s2">&quot;addresses.email_address&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="s2">&quot;title&quot;</span><span class="p">)</span>
<span class="gp">... </span><span class="p">])</span><span class="o">.</span>\
<span class="gp">... </span>   <span class="n">where</span><span class="p">(</span>
<span class="gp">... </span>       <span class="n">and_</span><span class="p">(</span>
<span class="gp">... </span>           <span class="n">literal_column</span><span class="p">(</span><span class="s2">&quot;users.id&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="n">literal_column</span><span class="p">(</span><span class="s2">&quot;addresses.user_id&quot;</span><span class="p">),</span>
<span class="gp">... </span>           <span class="n">text</span><span class="p">(</span><span class="s2">&quot;users.name BETWEEN &#39;m&#39; AND &#39;z&#39;&quot;</span><span class="p">),</span>
<span class="gp">... </span>           <span class="n">text</span><span class="p">(</span>
<span class="gp">... </span>               <span class="s2">&quot;(addresses.email_address LIKE :x OR &quot;</span>
<span class="gp">... </span>               <span class="s2">&quot;addresses.email_address LIKE :y)&quot;</span><span class="p">)</span>
<span class="gp">... </span>       <span class="p">)</span>
<span class="gp">... </span>   <span class="p">)</span><span class="o">.</span><span class="n">select_from</span><span class="p">(</span><span class="n">table</span><span class="p">(</span><span class="s1">&#39;users&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">select_from</span><span class="p">(</span><span class="n">table</span><span class="p">(</span><span class="s1">&#39;addresses&#39;</span><span class="p">))</span>

<span class=" -Sql -Sql-Link">{sql}</span><span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="s1">&#39;%@aol.com&#39;</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="s1">&#39;%@msn.com&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>
<span class=" -Sql -Sql-Popup">SELECT users.fullname || ? || addresses.email_address AS anon_1</span>
<span class=" -Sql -Sql-Popup">FROM users, addresses</span>
<span class=" -Sql -Sql-Popup">WHERE users.id = addresses.user_id</span>
<span class=" -Sql -Sql-Popup">AND users.name BETWEEN &#39;m&#39; AND &#39;z&#39;</span>
<span class=" -Sql -Sql-Popup">AND (addresses.email_address LIKE ? OR addresses.email_address LIKE ?)</span>
<span class=" -Sql -Sql-Popup">(&#39;, &#39;, &#39;%@aol.com&#39;, &#39;%@msn.com&#39;)</span>
<span class=" -Sql -Sql-Popup">{stop}</span><span class="go">[(u&#39;Wendy Williams, wendy@aol.com&#39;,)]</span>
</pre></div>
</div>
</div>
<div class="section" id="ordering-or-grouping-by-a-label">
<h3>Ordering or Grouping by a Label<a class="headerlink" href="#ordering-or-grouping-by-a-label" title="제목 주소">¶</a></h3>
<p>One place where we sometimes want to use a string as a shortcut is when
our statement has some labeled column element that we want to refer to in
a place such as the &quot;ORDER BY&quot; or &quot;GROUP BY&quot; clause; other candidates include
fields within an &quot;OVER&quot; or &quot;DISTINCT&quot; clause.  If we have such a label
in our <a class="reference internal" href="selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> construct, we can refer to it directly by passing the
string straight into <code class="xref py py-meth docutils literal notranslate"><span class="pre">select.order_by()</span></code> or <code class="xref py py-meth docutils literal notranslate"><span class="pre">select.group_by()</span></code>,
among others.  This will refer to the named label and also prevent the
expression from being rendered twice.  Label names that resolve to columns
are rendered fully:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">func</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span>
<span class="gp">... </span>        <span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">user_id</span><span class="p">,</span>
<span class="gp">... </span>        <span class="n">func</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">)</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="s1">&#39;num_addresses&#39;</span><span class="p">)])</span><span class="o">.</span>\
<span class="gp">... </span>        <span class="n">group_by</span><span class="p">(</span><span class="s2">&quot;user_id&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="s2">&quot;user_id&quot;</span><span class="p">,</span> <span class="s2">&quot;num_addresses&quot;</span><span class="p">)</span>

<span class=" -Sql -Sql-Link">{sql}</span><span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>
<span class=" -Sql -Sql-Popup">SELECT addresses.user_id, count(addresses.id) AS num_addresses</span>
<span class=" -Sql -Sql-Popup">FROM addresses GROUP BY addresses.user_id ORDER BY addresses.user_id, num_addresses</span>
<span class=" -Sql -Sql-Popup">()</span>
<span class=" -Sql -Sql-Popup">{stop}</span><span class="go">[(1, 2), (2, 2)]</span>
</pre></div>
</div>
<p>We can use modifiers like <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.expression.asc" title="sqlalchemy.sql.expression.asc"><code class="xref py py-func docutils literal notranslate"><span class="pre">asc()</span></code></a> or <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.expression.desc" title="sqlalchemy.sql.expression.desc"><code class="xref py py-func docutils literal notranslate"><span class="pre">desc()</span></code></a> by passing the string
name:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">func</span><span class="p">,</span> <span class="n">desc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span>
<span class="gp">... </span>        <span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">user_id</span><span class="p">,</span>
<span class="gp">... </span>        <span class="n">func</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">)</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="s1">&#39;num_addresses&#39;</span><span class="p">)])</span><span class="o">.</span>\
<span class="gp">... </span>        <span class="n">group_by</span><span class="p">(</span><span class="s2">&quot;user_id&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="s2">&quot;user_id&quot;</span><span class="p">,</span> <span class="n">desc</span><span class="p">(</span><span class="s2">&quot;num_addresses&quot;</span><span class="p">))</span>

<span class=" -Sql -Sql-Link">{sql}</span><span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>
<span class=" -Sql -Sql-Popup">SELECT addresses.user_id, count(addresses.id) AS num_addresses</span>
<span class=" -Sql -Sql-Popup">FROM addresses GROUP BY addresses.user_id ORDER BY addresses.user_id, num_addresses DESC</span>
<span class=" -Sql -Sql-Popup">()</span>
<span class=" -Sql -Sql-Popup">{stop}</span><span class="go">[(1, 2), (2, 2)]</span>
</pre></div>
</div>
<p>Note that the string feature here is very much tailored to when we have
already used the <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.expression.ColumnElement.label" title="sqlalchemy.sql.expression.ColumnElement.label"><code class="xref py py-meth docutils literal notranslate"><span class="pre">label()</span></code></a> method to create a
specifically-named label.  In other cases, we always want to refer to the
<a class="reference internal" href="sqlelement.html#sqlalchemy.sql.expression.ColumnElement" title="sqlalchemy.sql.expression.ColumnElement"><code class="xref py py-class docutils literal notranslate"><span class="pre">ColumnElement</span></code></a> object directly so that the expression system can
make the most effective choices for rendering.  Below, we illustrate how using
the <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.expression.ColumnElement" title="sqlalchemy.sql.expression.ColumnElement"><code class="xref py py-class docutils literal notranslate"><span class="pre">ColumnElement</span></code></a> eliminates ambiguity when we want to order
by a column name that appears more than once:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">u1a</span><span class="p">,</span> <span class="n">u1b</span> <span class="o">=</span> <span class="n">users</span><span class="o">.</span><span class="n">alias</span><span class="p">(),</span> <span class="n">users</span><span class="o">.</span><span class="n">alias</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span><span class="n">u1a</span><span class="p">,</span> <span class="n">u1b</span><span class="p">])</span><span class="o">.</span>\
<span class="gp">... </span>            <span class="n">where</span><span class="p">(</span><span class="n">u1a</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span> <span class="o">&gt;</span> <span class="n">u1b</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">)</span><span class="o">.</span>\
<span class="gp">... </span>            <span class="n">order_by</span><span class="p">(</span><span class="n">u1a</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>  <span class="c1"># using &quot;name&quot; here would be ambiguous</span>

<span class=" -Sql -Sql-Link">{sql}</span><span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>
<span class=" -Sql -Sql-Popup">SELECT users_1.id, users_1.name, users_1.fullname, users_2.id,</span>
<span class=" -Sql -Sql-Popup">users_2.name, users_2.fullname</span>
<span class=" -Sql -Sql-Popup">FROM users AS users_1, users AS users_2</span>
<span class=" -Sql -Sql-Popup">WHERE users_1.name &gt; users_2.name ORDER BY users_1.name</span>
<span class=" -Sql -Sql-Popup">()</span>
<span class=" -Sql -Sql-Popup">{stop}</span><span class="go">[(2, u&#39;wendy&#39;, u&#39;Wendy Williams&#39;, 1, u&#39;jack&#39;, u&#39;Jack Jones&#39;)]</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="using-aliases">
<h2>Using Aliases<a class="headerlink" href="#using-aliases" title="제목 주소">¶</a></h2>
<p>The alias in SQL corresponds to a &quot;renamed&quot; version of a table or SELECT
statement, which occurs anytime you say &quot;SELECT .. FROM sometable AS
someothername&quot;. The <code class="docutils literal notranslate"><span class="pre">AS</span></code> creates a new name for the table. Aliases are a key
construct as they allow any table or subquery to be referenced by a unique
name. In the case of a table, this allows the same table to be named in the
FROM clause multiple times. In the case of a SELECT statement, it provides a
parent name for the columns represented by the statement, allowing them to be
referenced relative to this name.</p>
<p>In SQLAlchemy, any <a class="reference internal" href="metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>, <a class="reference internal" href="selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> construct, or
other selectable can be turned into an alias using the <a class="reference internal" href="selectable.html#sqlalchemy.sql.expression.FromClause.alias" title="sqlalchemy.sql.expression.FromClause.alias"><code class="xref py py-meth docutils literal notranslate"><span class="pre">FromClause.alias()</span></code></a>
method, which produces a <a class="reference internal" href="selectable.html#sqlalchemy.sql.expression.Alias" title="sqlalchemy.sql.expression.Alias"><code class="xref py py-class docutils literal notranslate"><span class="pre">Alias</span></code></a> construct.  As an example, suppose we know that our user <code class="docutils literal notranslate"><span class="pre">jack</span></code> has two
particular email addresses. How can we locate jack based on the combination of those two
addresses?   To accomplish this, we'd use a join to the <code class="docutils literal notranslate"><span class="pre">addresses</span></code> table,
once for each address.   We create two <a class="reference internal" href="selectable.html#sqlalchemy.sql.expression.Alias" title="sqlalchemy.sql.expression.Alias"><code class="xref py py-class docutils literal notranslate"><span class="pre">Alias</span></code></a> constructs against
<code class="docutils literal notranslate"><span class="pre">addresses</span></code>, and then use them both within a <a class="reference internal" href="selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> construct:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a1</span> <span class="o">=</span> <span class="n">addresses</span><span class="o">.</span><span class="n">alias</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a2</span> <span class="o">=</span> <span class="n">addresses</span><span class="o">.</span><span class="n">alias</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span><span class="n">users</span><span class="p">])</span><span class="o">.</span>\
<span class="gp">... </span>       <span class="n">where</span><span class="p">(</span><span class="n">and_</span><span class="p">(</span>
<span class="gp">... </span>           <span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">a1</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">user_id</span><span class="p">,</span>
<span class="gp">... </span>           <span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">a2</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">user_id</span><span class="p">,</span>
<span class="gp">... </span>           <span class="n">a1</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">email_address</span> <span class="o">==</span> <span class="s1">&#39;jack@msn.com&#39;</span><span class="p">,</span>
<span class="gp">... </span>           <span class="n">a2</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">email_address</span> <span class="o">==</span> <span class="s1">&#39;jack@yahoo.com&#39;</span>
<span class="gp">... </span>       <span class="p">))</span>
<span class=" -Sql -Sql-Link">{sql}</span><span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>
<span class=" -Sql -Sql-Popup">SELECT users.id, users.name, users.fullname</span>
<span class=" -Sql -Sql-Popup">FROM users, addresses AS addresses_1, addresses AS addresses_2</span>
<span class=" -Sql -Sql-Popup">WHERE users.id = addresses_1.user_id</span>
<span class=" -Sql -Sql-Popup">    AND users.id = addresses_2.user_id</span>
<span class=" -Sql -Sql-Popup">    AND addresses_1.email_address = ?</span>
<span class=" -Sql -Sql-Popup">    AND addresses_2.email_address = ?</span>
<span class=" -Sql -Sql-Popup">(&#39;jack@msn.com&#39;, &#39;jack@yahoo.com&#39;)</span>
<span class=" -Sql -Sql-Popup">{stop}</span><span class="go">[(1, u&#39;jack&#39;, u&#39;Jack Jones&#39;)]</span>
</pre></div>
</div>
<p>Note that the <a class="reference internal" href="selectable.html#sqlalchemy.sql.expression.Alias" title="sqlalchemy.sql.expression.Alias"><code class="xref py py-class docutils literal notranslate"><span class="pre">Alias</span></code></a> construct generated the names <code class="docutils literal notranslate"><span class="pre">addresses_1</span></code> and
<code class="docutils literal notranslate"><span class="pre">addresses_2</span></code> in the final SQL result.  The generation of these names is determined
by the position of the construct within the statement.   If we created a query using
only the second <code class="docutils literal notranslate"><span class="pre">a2</span></code> alias, the name would come out as <code class="docutils literal notranslate"><span class="pre">addresses_1</span></code>.  The
generation of the names is also <em>deterministic</em>, meaning the same SQLAlchemy
statement construct will produce the identical SQL string each time it is
rendered for a particular dialect.</p>
<p>Since on the outside, we refer to the alias using the <a class="reference internal" href="selectable.html#sqlalchemy.sql.expression.Alias" title="sqlalchemy.sql.expression.Alias"><code class="xref py py-class docutils literal notranslate"><span class="pre">Alias</span></code></a> construct
itself, we don't need to be concerned about the generated name.  However, for
the purposes of debugging, it can be specified by passing a string name
to the <a class="reference internal" href="selectable.html#sqlalchemy.sql.expression.FromClause.alias" title="sqlalchemy.sql.expression.FromClause.alias"><code class="xref py py-meth docutils literal notranslate"><span class="pre">FromClause.alias()</span></code></a> method:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a1</span> <span class="o">=</span> <span class="n">addresses</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="s1">&#39;a1&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Aliases can of course be used for anything which you can SELECT from,
including SELECT statements themselves. We can self-join the <code class="docutils literal notranslate"><span class="pre">users</span></code> table
back to the <a class="reference internal" href="selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> we've created by making an alias of the entire
statement. The <code class="docutils literal notranslate"><span class="pre">correlate(None)</span></code> directive is to avoid SQLAlchemy's attempt
to &quot;correlate&quot; the inner <code class="docutils literal notranslate"><span class="pre">users</span></code> table with the outer one:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a1</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">correlate</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span><span class="o">.</span><span class="n">alias</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">])</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">a1</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
<span class=" -Sql -Sql-Link">{sql}</span><span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>
<span class=" -Sql -Sql-Popup">SELECT users.name</span>
<span class=" -Sql -Sql-Popup">FROM users,</span>
<span class=" -Sql -Sql-Popup">    (SELECT users.id AS id, users.name AS name, users.fullname AS fullname</span>
<span class=" -Sql -Sql-Popup">        FROM users, addresses AS addresses_1, addresses AS addresses_2</span>
<span class=" -Sql -Sql-Popup">        WHERE users.id = addresses_1.user_id AND users.id = addresses_2.user_id</span>
<span class=" -Sql -Sql-Popup">        AND addresses_1.email_address = ?</span>
<span class=" -Sql -Sql-Popup">        AND addresses_2.email_address = ?) AS anon_1</span>
<span class=" -Sql -Sql-Popup">WHERE users.id = anon_1.id</span>
<span class=" -Sql -Sql-Popup">(&#39;jack@msn.com&#39;, &#39;jack@yahoo.com&#39;)</span>
<span class=" -Sql -Sql-Popup">{stop}</span><span class="go">[(u&#39;jack&#39;,)]</span>
</pre></div>
</div>
</div>
<div class="section" id="using-joins">
<h2>Using Joins<a class="headerlink" href="#using-joins" title="제목 주소">¶</a></h2>
<p>We're halfway along to being able to construct any SELECT expression. The next
cornerstone of the SELECT is the JOIN expression. We've already been doing
joins in our examples, by just placing two tables in either the columns clause
or the where clause of the <a class="reference internal" href="selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> construct. But if we want to make a
real &quot;JOIN&quot; or &quot;OUTERJOIN&quot; construct, we use the <a class="reference internal" href="selectable.html#sqlalchemy.sql.expression.FromClause.join" title="sqlalchemy.sql.expression.FromClause.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">join()</span></code></a> and
<a class="reference internal" href="selectable.html#sqlalchemy.sql.expression.FromClause.outerjoin" title="sqlalchemy.sql.expression.FromClause.outerjoin"><code class="xref py py-meth docutils literal notranslate"><span class="pre">outerjoin()</span></code></a> methods, most commonly accessed from the left table in the
join:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">addresses</span><span class="p">))</span>
<span class="go">users JOIN addresses ON users.id = addresses.user_id</span>
</pre></div>
</div>
<p>The alert reader will see more surprises; SQLAlchemy figured out how to JOIN
the two tables ! The ON condition of the join, as it's called, was
automatically generated based on the <a class="reference internal" href="constraints.html#sqlalchemy.schema.ForeignKey" title="sqlalchemy.schema.ForeignKey"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKey</span></code></a>
object which we placed on the <code class="docutils literal notranslate"><span class="pre">addresses</span></code> table way at the beginning of this
tutorial. Already the <code class="docutils literal notranslate"><span class="pre">join()</span></code> construct is looking like a much better way
to join tables.</p>
<p>Of course you can join on whatever expression you want, such as if we want to
join on all users who use the same name in their email address as their
username:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">addresses</span><span class="p">,</span>
<span class="gp">... </span>                <span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">email_address</span><span class="o">.</span><span class="n">like</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;%&#39;</span><span class="p">)</span>
<span class="gp">... </span>            <span class="p">)</span>
<span class="gp">... </span> <span class="p">)</span>
<span class="go">users JOIN addresses ON addresses.email_address LIKE users.name || :name_1</span>
</pre></div>
</div>
<p>When we create a <a class="reference internal" href="selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> construct, SQLAlchemy looks around at the
tables we've mentioned and then places them in the FROM clause of the
statement. When we use JOINs however, we know what FROM clause we want, so
here we make use of the <a class="reference internal" href="selectable.html#sqlalchemy.sql.expression.Select.select_from" title="sqlalchemy.sql.expression.Select.select_from"><code class="xref py py-meth docutils literal notranslate"><span class="pre">select_from()</span></code></a> method:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">fullname</span><span class="p">])</span><span class="o">.</span><span class="n">select_from</span><span class="p">(</span>
<span class="gp">... </span>   <span class="n">users</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">addresses</span><span class="p">,</span>
<span class="gp">... </span>            <span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">email_address</span><span class="o">.</span><span class="n">like</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;%&#39;</span><span class="p">))</span>
<span class="gp">... </span>   <span class="p">)</span>
<span class=" -Sql -Sql-Link">{sql}</span><span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>
<span class=" -Sql -Sql-Popup">SELECT users.fullname</span>
<span class=" -Sql -Sql-Popup">FROM users JOIN addresses ON addresses.email_address LIKE users.name || ?</span>
<span class=" -Sql -Sql-Popup">(&#39;%&#39;,)</span>
<span class=" -Sql -Sql-Popup">{stop}</span><span class="go">[(u&#39;Jack Jones&#39;,), (u&#39;Jack Jones&#39;,), (u&#39;Wendy Williams&#39;,)]</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="selectable.html#sqlalchemy.sql.expression.FromClause.outerjoin" title="sqlalchemy.sql.expression.FromClause.outerjoin"><code class="xref py py-meth docutils literal notranslate"><span class="pre">outerjoin()</span></code></a> method creates <code class="docutils literal notranslate"><span class="pre">LEFT</span> <span class="pre">OUTER</span> <span class="pre">JOIN</span></code> constructs,
and is used in the same way as <a class="reference internal" href="selectable.html#sqlalchemy.sql.expression.FromClause.join" title="sqlalchemy.sql.expression.FromClause.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">join()</span></code></a>:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">fullname</span><span class="p">])</span><span class="o">.</span><span class="n">select_from</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">outerjoin</span><span class="p">(</span><span class="n">addresses</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">SELECT users.fullname</span>
<span class="go">    FROM users</span>
<span class="go">    LEFT OUTER JOIN addresses ON users.id = addresses.user_id</span>
</pre></div>
</div>
<p>That's the output <code class="docutils literal notranslate"><span class="pre">outerjoin()</span></code> produces, unless, of course, you're stuck in
a gig using Oracle prior to version 9, and you've set up your engine (which
would be using <code class="docutils literal notranslate"><span class="pre">OracleDialect</span></code>) to use Oracle-specific SQL:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy.dialects.oracle</span> <span class="kn">import</span> <span class="n">dialect</span> <span class="k">as</span> <span class="n">OracleDialect</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">dialect</span><span class="o">=</span><span class="n">OracleDialect</span><span class="p">(</span><span class="n">use_ansi</span><span class="o">=</span><span class="bp">False</span><span class="p">)))</span>
<span class="go">SELECT users.fullname</span>
<span class="go">FROM users, addresses</span>
<span class="go">WHERE users.id = addresses.user_id(+)</span>
</pre></div>
</div>
<p>If you don't know what that SQL means, don't worry ! The secret tribe of
Oracle DBAs don't want their black magic being found out ;).</p>
<div class="admonition seealso">
<p class="first admonition-title">더 보기</p>
<p><a class="reference internal" href="selectable.html#sqlalchemy.sql.expression.join" title="sqlalchemy.sql.expression.join"><code class="xref py py-func docutils literal notranslate"><span class="pre">expression.join()</span></code></a></p>
<p><a class="reference internal" href="selectable.html#sqlalchemy.sql.expression.outerjoin" title="sqlalchemy.sql.expression.outerjoin"><code class="xref py py-func docutils literal notranslate"><span class="pre">expression.outerjoin()</span></code></a></p>
<p class="last"><a class="reference internal" href="selectable.html#sqlalchemy.sql.expression.Join" title="sqlalchemy.sql.expression.Join"><code class="xref py py-class docutils literal notranslate"><span class="pre">Join</span></code></a></p>
</div>
</div>
<div class="section" id="everything-else">
<h2>Everything Else<a class="headerlink" href="#everything-else" title="제목 주소">¶</a></h2>
<p>The concepts of creating SQL expressions have been introduced. What's left are
more variants of the same themes. So now we'll catalog the rest of the
important things we'll need to know.</p>
<div class="section" id="bind-parameter-objects">
<span id="coretutorial-bind-param"></span><h3>Bind Parameter Objects<a class="headerlink" href="#bind-parameter-objects" title="제목 주소">¶</a></h3>
<p>Throughout all these examples, SQLAlchemy is busy creating bind parameters
wherever literal expressions occur. You can also specify your own bind
parameters with your own names, and use the same statement repeatedly.
The <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.expression.bindparam" title="sqlalchemy.sql.expression.bindparam"><code class="xref py py-func docutils literal notranslate"><span class="pre">bindparam()</span></code></a> construct is used to produce a bound parameter
with a given name.  While SQLAlchemy always refers to bound parameters by
name on the API side, the
database dialect converts to the appropriate named or positional style
at execution time, as here where it converts to positional for SQLite:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy.sql</span> <span class="kn">import</span> <span class="n">bindparam</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">users</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">bindparam</span><span class="p">(</span><span class="s1">&#39;username&#39;</span><span class="p">))</span>
<span class=" -Sql -Sql-Link">{sql}</span><span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">username</span><span class="o">=</span><span class="s1">&#39;wendy&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>
<span class=" -Sql -Sql-Popup">SELECT users.id, users.name, users.fullname</span>
<span class=" -Sql -Sql-Popup">FROM users</span>
<span class=" -Sql -Sql-Popup">WHERE users.name = ?</span>
<span class=" -Sql -Sql-Popup">(&#39;wendy&#39;,)</span>
<span class=" -Sql -Sql-Popup">{stop}</span><span class="go">[(2, u&#39;wendy&#39;, u&#39;Wendy Williams&#39;)]</span>
</pre></div>
</div>
<p>Another important aspect of <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.expression.bindparam" title="sqlalchemy.sql.expression.bindparam"><code class="xref py py-func docutils literal notranslate"><span class="pre">bindparam()</span></code></a> is that it may be assigned a
type. The type of the bind parameter will determine its behavior within
expressions and also how the data bound to it is processed before being sent
off to the database:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">users</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">like</span><span class="p">(</span><span class="n">bindparam</span><span class="p">(</span><span class="s1">&#39;username&#39;</span><span class="p">,</span> <span class="n">type_</span><span class="o">=</span><span class="n">String</span><span class="p">)</span> <span class="o">+</span> <span class="n">text</span><span class="p">(</span><span class="s2">&quot;&#39;%&#39;&quot;</span><span class="p">)))</span>
<span class=" -Sql -Sql-Link">{sql}</span><span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">username</span><span class="o">=</span><span class="s1">&#39;wendy&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>
<span class=" -Sql -Sql-Popup">SELECT users.id, users.name, users.fullname</span>
<span class=" -Sql -Sql-Popup">FROM users</span>
<span class=" -Sql -Sql-Popup">WHERE users.name LIKE ? || &#39;%&#39;</span>
<span class=" -Sql -Sql-Popup">(&#39;wendy&#39;,)</span>
<span class=" -Sql -Sql-Popup">{stop}</span><span class="go">[(2, u&#39;wendy&#39;, u&#39;Wendy Williams&#39;)]</span>
</pre></div>
</div>
<p><a class="reference internal" href="sqlelement.html#sqlalchemy.sql.expression.bindparam" title="sqlalchemy.sql.expression.bindparam"><code class="xref py py-func docutils literal notranslate"><span class="pre">bindparam()</span></code></a> constructs of the same name can also be used multiple times, where only a
single named value is needed in the execute parameters:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span><span class="n">users</span><span class="p">,</span> <span class="n">addresses</span><span class="p">])</span><span class="o">.</span>\
<span class="gp">... </span>    <span class="n">where</span><span class="p">(</span>
<span class="gp">... </span>       <span class="n">or_</span><span class="p">(</span>
<span class="gp">... </span>         <span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">like</span><span class="p">(</span>
<span class="gp">... </span>                <span class="n">bindparam</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="n">type_</span><span class="o">=</span><span class="n">String</span><span class="p">)</span> <span class="o">+</span> <span class="n">text</span><span class="p">(</span><span class="s2">&quot;&#39;%&#39;&quot;</span><span class="p">)),</span>
<span class="gp">... </span>         <span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">email_address</span><span class="o">.</span><span class="n">like</span><span class="p">(</span>
<span class="gp">... </span>                <span class="n">bindparam</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="n">type_</span><span class="o">=</span><span class="n">String</span><span class="p">)</span> <span class="o">+</span> <span class="n">text</span><span class="p">(</span><span class="s2">&quot;&#39;@%&#39;&quot;</span><span class="p">))</span>
<span class="gp">... </span>       <span class="p">)</span>
<span class="gp">... </span>    <span class="p">)</span><span class="o">.</span>\
<span class="gp">... </span>    <span class="n">select_from</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">outerjoin</span><span class="p">(</span><span class="n">addresses</span><span class="p">))</span><span class="o">.</span>\
<span class="gp">... </span>    <span class="n">order_by</span><span class="p">(</span><span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
<span class=" -Sql -Sql-Link">{sql}</span><span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;jack&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>
<span class=" -Sql -Sql-Popup">SELECT users.id, users.name, users.fullname, addresses.id,</span>
<span class=" -Sql -Sql-Popup">    addresses.user_id, addresses.email_address</span>
<span class=" -Sql -Sql-Popup">FROM users LEFT OUTER JOIN addresses ON users.id = addresses.user_id</span>
<span class=" -Sql -Sql-Popup">WHERE users.name LIKE ? || &#39;%&#39; OR addresses.email_address LIKE ? || &#39;@%&#39;</span>
<span class=" -Sql -Sql-Popup">ORDER BY addresses.id</span>
<span class=" -Sql -Sql-Popup">(&#39;jack&#39;, &#39;jack&#39;)</span>
<span class=" -Sql -Sql-Popup">{stop}</span><span class="go">[(1, u&#39;jack&#39;, u&#39;Jack Jones&#39;, 1, 1, u&#39;jack@yahoo.com&#39;), (1, u&#39;jack&#39;, u&#39;Jack Jones&#39;, 2, 1, u&#39;jack@msn.com&#39;)]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">더 보기</p>
<p class="last"><a class="reference internal" href="sqlelement.html#sqlalchemy.sql.expression.bindparam" title="sqlalchemy.sql.expression.bindparam"><code class="xref py py-func docutils literal notranslate"><span class="pre">bindparam()</span></code></a></p>
</div>
</div>
<div class="section" id="functions">
<h3>Functions<a class="headerlink" href="#functions" title="제목 주소">¶</a></h3>
<p>SQL functions are created using the <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.expression.func" title="sqlalchemy.sql.expression.func"><code class="xref py py-data docutils literal notranslate"><span class="pre">func</span></code></a> keyword, which
generates functions using attribute access:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy.sql</span> <span class="kn">import</span> <span class="n">func</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">now</span><span class="p">())</span>
<span class="go">now()</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">))</span>
<span class="go">concat(:concat_1, :concat_2)</span>
</pre></div>
</div>
<p>By &quot;generates&quot;, we mean that <strong>any</strong> SQL function is created based on the word
you choose:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">xyz_my_goofy_function</span><span class="p">())</span>
<span class="go">xyz_my_goofy_function()</span>
</pre></div>
</div>
<p>Certain function names are known by SQLAlchemy, allowing special behavioral
rules to be applied. Some for example are &quot;ANSI&quot; functions, which mean they
don't get the parenthesis added after them, such as CURRENT_TIMESTAMP:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">current_timestamp</span><span class="p">())</span>
<span class="go">CURRENT_TIMESTAMP</span>
</pre></div>
</div>
<p>Functions are most typically used in the columns clause of a select statement,
and can also be labeled as well as given a type. Labeling a function is
recommended so that the result can be targeted in a result row based on a
string name, and assigning it a type is required when you need result-set
processing to occur, such as for Unicode conversion and date conversions.
Below, we use the result function <code class="docutils literal notranslate"><span class="pre">scalar()</span></code> to just read the first column
of the first row and then close the result; the label, even though present, is
not important in this case:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">select</span><span class="p">([</span>
<span class="gp">... </span>           <span class="n">func</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">email_address</span><span class="p">,</span> <span class="n">type_</span><span class="o">=</span><span class="n">String</span><span class="p">)</span><span class="o">.</span>
<span class="gp">... </span>               <span class="n">label</span><span class="p">(</span><span class="s1">&#39;maxemail&#39;</span><span class="p">)</span>
<span class="gp">... </span>          <span class="p">])</span>
<span class="gp">... </span>    <span class="p">)</span><span class="o">.</span><span class="n">scalar</span><span class="p">()</span>
<span class=" -Sql -Sql-Open">{opensql}</span><span class=" -Sql">SELECT max(addresses.email_address) AS maxemail</span>
<span class=" -Sql">FROM addresses</span>
<span class=" -Sql">()</span>
<span class=" -Sql">{stop}</span><span class="go">u&#39;www@www.org&#39;</span>
</pre></div>
</div>
<p>Databases such as PostgreSQL and Oracle which support functions that return
whole result sets can be assembled into selectable units, which can be used in
statements. Such as, a database function <code class="docutils literal notranslate"><span class="pre">calculate()</span></code> which takes the
parameters <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code>, and returns three columns which we'd like to name
<code class="docutils literal notranslate"><span class="pre">q</span></code>, <code class="docutils literal notranslate"><span class="pre">z</span></code> and <code class="docutils literal notranslate"><span class="pre">r</span></code>, we can construct using &quot;lexical&quot; column objects as
well as bind parameters:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy.sql</span> <span class="kn">import</span> <span class="n">column</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">calculate</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span><span class="n">column</span><span class="p">(</span><span class="s1">&#39;q&#39;</span><span class="p">),</span> <span class="n">column</span><span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">),</span> <span class="n">column</span><span class="p">(</span><span class="s1">&#39;r&#39;</span><span class="p">)])</span><span class="o">.</span>\
<span class="gp">... </span>       <span class="n">select_from</span><span class="p">(</span>
<span class="gp">... </span>            <span class="n">func</span><span class="o">.</span><span class="n">calculate</span><span class="p">(</span>
<span class="gp">... </span>                   <span class="n">bindparam</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">),</span>
<span class="gp">... </span>                   <span class="n">bindparam</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">)</span>
<span class="gp">... </span>               <span class="p">)</span>
<span class="gp">... </span>            <span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">calc</span> <span class="o">=</span> <span class="n">calculate</span><span class="o">.</span><span class="n">alias</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">select</span><span class="p">([</span><span class="n">users</span><span class="p">])</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span> <span class="o">&gt;</span> <span class="n">calc</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">z</span><span class="p">))</span>
<span class="go">SELECT users.id, users.name, users.fullname</span>
<span class="go">FROM users, (SELECT q, z, r</span>
<span class="go">FROM calculate(:x, :y)) AS anon_1</span>
<span class="go">WHERE users.id &gt; anon_1.z</span>
</pre></div>
</div>
<p>If we wanted to use our <code class="docutils literal notranslate"><span class="pre">calculate</span></code> statement twice with different bind
parameters, the <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.expression.ClauseElement.unique_params" title="sqlalchemy.sql.expression.ClauseElement.unique_params"><code class="xref py py-func docutils literal notranslate"><span class="pre">unique_params()</span></code></a>
function will create copies for us, and mark the bind parameters as &quot;unique&quot;
so that conflicting names are isolated. Note we also make two separate aliases
of our selectable:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">calc1</span> <span class="o">=</span> <span class="n">calculate</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="s1">&#39;c1&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">unique_params</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">17</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">45</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">calc2</span> <span class="o">=</span> <span class="n">calculate</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="s1">&#39;c2&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">unique_params</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span><span class="n">users</span><span class="p">])</span><span class="o">.</span>\
<span class="gp">... </span>        <span class="n">where</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="o">.</span><span class="n">between</span><span class="p">(</span><span class="n">calc1</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">calc2</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">z</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">SELECT users.id, users.name, users.fullname</span>
<span class="go">FROM users,</span>
<span class="go">    (SELECT q, z, r FROM calculate(:x_1, :y_1)) AS c1,</span>
<span class="go">    (SELECT q, z, r FROM calculate(:x_2, :y_2)) AS c2</span>
<span class="go">WHERE users.id BETWEEN c1.z AND c2.z</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">compile</span><span class="p">()</span><span class="o">.</span><span class="n">params</span> <span class="c1"># doctest: +SKIP</span>
<span class="go">{u&#39;x_2&#39;: 5, u&#39;y_2&#39;: 12, u&#39;y_1&#39;: 45, u&#39;x_1&#39;: 17}</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">더 보기</p>
<p class="last"><a class="reference internal" href="sqlelement.html#sqlalchemy.sql.expression.func" title="sqlalchemy.sql.expression.func"><code class="xref py py-data docutils literal notranslate"><span class="pre">func</span></code></a></p>
</div>
</div>
<div class="section" id="window-functions">
<span id="id1"></span><h3>Window Functions<a class="headerlink" href="#window-functions" title="제목 주소">¶</a></h3>
<p>Any <a class="reference internal" href="functions.html#sqlalchemy.sql.functions.FunctionElement" title="sqlalchemy.sql.functions.FunctionElement"><code class="xref py py-class docutils literal notranslate"><span class="pre">FunctionElement</span></code></a>, including functions generated by
<a class="reference internal" href="sqlelement.html#sqlalchemy.sql.expression.func" title="sqlalchemy.sql.expression.func"><code class="xref py py-data docutils literal notranslate"><span class="pre">func</span></code></a>, can be turned into a &quot;window function&quot;, that is an
OVER clause, using the <a class="reference internal" href="functions.html#sqlalchemy.sql.functions.FunctionElement.over" title="sqlalchemy.sql.functions.FunctionElement.over"><code class="xref py py-meth docutils literal notranslate"><span class="pre">FunctionElement.over()</span></code></a> method:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span>
<span class="gp">... </span>        <span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">,</span>
<span class="gp">... </span>        <span class="n">func</span><span class="o">.</span><span class="n">row_number</span><span class="p">()</span><span class="o">.</span><span class="n">over</span><span class="p">(</span><span class="n">order_by</span><span class="o">=</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
<span class="gp">... </span>    <span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">SELECT users.id, row_number() OVER (ORDER BY users.name) AS anon_1</span>
<span class="go">FROM users</span>
</pre></div>
</div>
<p><a class="reference internal" href="functions.html#sqlalchemy.sql.functions.FunctionElement.over" title="sqlalchemy.sql.functions.FunctionElement.over"><code class="xref py py-meth docutils literal notranslate"><span class="pre">FunctionElement.over()</span></code></a> also supports range specification using
either the <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.expression.over.params.rows" title="sqlalchemy.sql.expression.over"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">expression.over.rows</span></code></a> or
<a class="reference internal" href="sqlelement.html#sqlalchemy.sql.expression.over.params.range" title="sqlalchemy.sql.expression.over"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">expression.over.range</span></code></a> parameters:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span>
<span class="gp">... </span>        <span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">,</span>
<span class="gp">... </span>        <span class="n">func</span><span class="o">.</span><span class="n">row_number</span><span class="p">()</span><span class="o">.</span><span class="n">over</span><span class="p">(</span>
<span class="gp">... </span>                <span class="n">order_by</span><span class="o">=</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
<span class="gp">... </span>                <span class="n">rows</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
<span class="gp">... </span>    <span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">SELECT users.id, row_number() OVER</span>
<span class="go">(ORDER BY users.name ROWS BETWEEN :param_1 PRECEDING AND UNBOUNDED FOLLOWING) AS anon_1</span>
<span class="go">FROM users</span>
</pre></div>
</div>
<p><a class="reference internal" href="sqlelement.html#sqlalchemy.sql.expression.over.params.rows" title="sqlalchemy.sql.expression.over"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">expression.over.rows</span></code></a> and <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.expression.over.params.range" title="sqlalchemy.sql.expression.over"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">expression.over.range</span></code></a> each
accept a two-tuple which contains a combination of negative and positive
integers for ranges, zero to indicate &quot;CURRENT ROW&quot; and <code class="docutils literal notranslate"><span class="pre">None</span></code> to
indicate &quot;UNBOUNDED&quot;.  See the examples at <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.expression.over" title="sqlalchemy.sql.expression.over"><code class="xref py py-func docutils literal notranslate"><span class="pre">over()</span></code></a> for more detail.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 1.1에 추가: </span>support for &quot;rows&quot; and &quot;range&quot; specification for
window functions</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">더 보기</p>
<p><a class="reference internal" href="sqlelement.html#sqlalchemy.sql.expression.over" title="sqlalchemy.sql.expression.over"><code class="xref py py-func docutils literal notranslate"><span class="pre">over()</span></code></a></p>
<p class="last"><a class="reference internal" href="functions.html#sqlalchemy.sql.functions.FunctionElement.over" title="sqlalchemy.sql.functions.FunctionElement.over"><code class="xref py py-meth docutils literal notranslate"><span class="pre">FunctionElement.over()</span></code></a></p>
</div>
</div>
<div class="section" id="unions-and-other-set-operations">
<h3>Unions and Other Set Operations<a class="headerlink" href="#unions-and-other-set-operations" title="제목 주소">¶</a></h3>
<p>Unions come in two flavors, UNION and UNION ALL, which are available via
module level functions <a class="reference internal" href="selectable.html#sqlalchemy.sql.expression.union" title="sqlalchemy.sql.expression.union"><code class="xref py py-func docutils literal notranslate"><span class="pre">union()</span></code></a> and
<a class="reference internal" href="selectable.html#sqlalchemy.sql.expression.union_all" title="sqlalchemy.sql.expression.union_all"><code class="xref py py-func docutils literal notranslate"><span class="pre">union_all()</span></code></a>:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy.sql</span> <span class="kn">import</span> <span class="n">union</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">=</span> <span class="n">union</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">addresses</span><span class="o">.</span><span class="n">select</span><span class="p">()</span><span class="o">.</span>
<span class="gp">... </span>            <span class="n">where</span><span class="p">(</span><span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">email_address</span> <span class="o">==</span> <span class="s1">&#39;foo@bar.com&#39;</span><span class="p">),</span>
<span class="gp">... </span>   <span class="n">addresses</span><span class="o">.</span><span class="n">select</span><span class="p">()</span><span class="o">.</span>
<span class="gp">... </span>            <span class="n">where</span><span class="p">(</span><span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">email_address</span><span class="o">.</span><span class="n">like</span><span class="p">(</span><span class="s1">&#39;%@yahoo.com&#39;</span><span class="p">)),</span>
<span class="gp">... </span><span class="p">)</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">email_address</span><span class="p">)</span>

<span class=" -Sql -Sql-Link">{sql}</span><span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">u</span><span class="p">)</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>
<span class=" -Sql -Sql-Popup">SELECT addresses.id, addresses.user_id, addresses.email_address</span>
<span class=" -Sql -Sql-Popup">FROM addresses</span>
<span class=" -Sql -Sql-Popup">WHERE addresses.email_address = ?</span>
<span class=" -Sql -Sql-Popup">UNION</span>
<span class=" -Sql -Sql-Popup">SELECT addresses.id, addresses.user_id, addresses.email_address</span>
<span class=" -Sql -Sql-Popup">FROM addresses</span>
<span class=" -Sql -Sql-Popup">WHERE addresses.email_address LIKE ? ORDER BY addresses.email_address</span>
<span class=" -Sql -Sql-Popup">(&#39;foo@bar.com&#39;, &#39;%@yahoo.com&#39;)</span>
<span class=" -Sql -Sql-Popup">{stop}</span><span class="go">[(1, 1, u&#39;jack@yahoo.com&#39;)]</span>
</pre></div>
</div>
<p>Also available, though not supported on all databases, are
<a class="reference internal" href="selectable.html#sqlalchemy.sql.expression.intersect" title="sqlalchemy.sql.expression.intersect"><code class="xref py py-func docutils literal notranslate"><span class="pre">intersect()</span></code></a>,
<a class="reference internal" href="selectable.html#sqlalchemy.sql.expression.intersect_all" title="sqlalchemy.sql.expression.intersect_all"><code class="xref py py-func docutils literal notranslate"><span class="pre">intersect_all()</span></code></a>,
<a class="reference internal" href="selectable.html#sqlalchemy.sql.expression.except_" title="sqlalchemy.sql.expression.except_"><code class="xref py py-func docutils literal notranslate"><span class="pre">except_()</span></code></a>, and <a class="reference internal" href="selectable.html#sqlalchemy.sql.expression.except_all" title="sqlalchemy.sql.expression.except_all"><code class="xref py py-func docutils literal notranslate"><span class="pre">except_all()</span></code></a>:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy.sql</span> <span class="kn">import</span> <span class="n">except_</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">=</span> <span class="n">except_</span><span class="p">(</span>
<span class="gp">... </span>   <span class="n">addresses</span><span class="o">.</span><span class="n">select</span><span class="p">()</span><span class="o">.</span>
<span class="gp">... </span>            <span class="n">where</span><span class="p">(</span><span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">email_address</span><span class="o">.</span><span class="n">like</span><span class="p">(</span><span class="s1">&#39;%@%.com&#39;</span><span class="p">)),</span>
<span class="gp">... </span>   <span class="n">addresses</span><span class="o">.</span><span class="n">select</span><span class="p">()</span><span class="o">.</span>
<span class="gp">... </span>            <span class="n">where</span><span class="p">(</span><span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">email_address</span><span class="o">.</span><span class="n">like</span><span class="p">(</span><span class="s1">&#39;%@msn.com&#39;</span><span class="p">))</span>
<span class="gp">... </span><span class="p">)</span>

<span class=" -Sql -Sql-Link">{sql}</span><span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">u</span><span class="p">)</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>
<span class=" -Sql -Sql-Popup">SELECT addresses.id, addresses.user_id, addresses.email_address</span>
<span class=" -Sql -Sql-Popup">FROM addresses</span>
<span class=" -Sql -Sql-Popup">WHERE addresses.email_address LIKE ?</span>
<span class=" -Sql -Sql-Popup">EXCEPT</span>
<span class=" -Sql -Sql-Popup">SELECT addresses.id, addresses.user_id, addresses.email_address</span>
<span class=" -Sql -Sql-Popup">FROM addresses</span>
<span class=" -Sql -Sql-Popup">WHERE addresses.email_address LIKE ?</span>
<span class=" -Sql -Sql-Popup">(&#39;%@%.com&#39;, &#39;%@msn.com&#39;)</span>
<span class=" -Sql -Sql-Popup">{stop}</span><span class="go">[(1, 1, u&#39;jack@yahoo.com&#39;), (4, 2, u&#39;wendy@aol.com&#39;)]</span>
</pre></div>
</div>
<p>A common issue with so-called &quot;compound&quot; selectables arises due to the fact
that they nest with parenthesis. SQLite in particular doesn't like a statement
that starts with parenthesis. So when nesting a &quot;compound&quot; inside a
&quot;compound&quot;, it's often necessary to apply <code class="docutils literal notranslate"><span class="pre">.alias().select()</span></code> to the first
element of the outermost compound, if that element is also a compound. For
example, to nest a &quot;union&quot; and a &quot;select&quot; inside of &quot;except_&quot;, SQLite will
want the &quot;union&quot; to be stated as a subquery:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">=</span> <span class="n">except_</span><span class="p">(</span>
<span class="gp">... </span>   <span class="n">union</span><span class="p">(</span>
<span class="gp">... </span>        <span class="n">addresses</span><span class="o">.</span><span class="n">select</span><span class="p">()</span><span class="o">.</span>
<span class="gp">... </span>            <span class="n">where</span><span class="p">(</span><span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">email_address</span><span class="o">.</span><span class="n">like</span><span class="p">(</span><span class="s1">&#39;%@yahoo.com&#39;</span><span class="p">)),</span>
<span class="gp">... </span>        <span class="n">addresses</span><span class="o">.</span><span class="n">select</span><span class="p">()</span><span class="o">.</span>
<span class="gp">... </span>            <span class="n">where</span><span class="p">(</span><span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">email_address</span><span class="o">.</span><span class="n">like</span><span class="p">(</span><span class="s1">&#39;%@msn.com&#39;</span><span class="p">))</span>
<span class="gp">... </span>    <span class="p">)</span><span class="o">.</span><span class="n">alias</span><span class="p">()</span><span class="o">.</span><span class="n">select</span><span class="p">(),</span>   <span class="c1"># apply subquery here</span>
<span class="gp">... </span>   <span class="n">addresses</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">email_address</span><span class="o">.</span><span class="n">like</span><span class="p">(</span><span class="s1">&#39;%@msn.com&#39;</span><span class="p">))</span>
<span class="gp">... </span><span class="p">)</span>
<span class=" -Sql -Sql-Link">{sql}</span><span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">u</span><span class="p">)</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>
<span class=" -Sql -Sql-Popup">SELECT anon_1.id, anon_1.user_id, anon_1.email_address</span>
<span class=" -Sql -Sql-Popup">FROM (SELECT addresses.id AS id, addresses.user_id AS user_id,</span>
<span class=" -Sql -Sql-Popup">    addresses.email_address AS email_address</span>
<span class=" -Sql -Sql-Popup">    FROM addresses</span>
<span class=" -Sql -Sql-Popup">    WHERE addresses.email_address LIKE ?</span>
<span class=" -Sql -Sql-Popup">    UNION</span>
<span class=" -Sql -Sql-Popup">    SELECT addresses.id AS id,</span>
<span class=" -Sql -Sql-Popup">        addresses.user_id AS user_id,</span>
<span class=" -Sql -Sql-Popup">        addresses.email_address AS email_address</span>
<span class=" -Sql -Sql-Popup">    FROM addresses</span>
<span class=" -Sql -Sql-Popup">    WHERE addresses.email_address LIKE ?) AS anon_1</span>
<span class=" -Sql -Sql-Popup">EXCEPT</span>
<span class=" -Sql -Sql-Popup">SELECT addresses.id, addresses.user_id, addresses.email_address</span>
<span class=" -Sql -Sql-Popup">FROM addresses</span>
<span class=" -Sql -Sql-Popup">WHERE addresses.email_address LIKE ?</span>
<span class=" -Sql -Sql-Popup">(&#39;%@yahoo.com&#39;, &#39;%@msn.com&#39;, &#39;%@msn.com&#39;)</span>
<span class=" -Sql -Sql-Popup">{stop}</span><span class="go">[(1, 1, u&#39;jack@yahoo.com&#39;)]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">더 보기</p>
<p><a class="reference internal" href="selectable.html#sqlalchemy.sql.expression.union" title="sqlalchemy.sql.expression.union"><code class="xref py py-func docutils literal notranslate"><span class="pre">union()</span></code></a></p>
<p><a class="reference internal" href="selectable.html#sqlalchemy.sql.expression.union_all" title="sqlalchemy.sql.expression.union_all"><code class="xref py py-func docutils literal notranslate"><span class="pre">union_all()</span></code></a></p>
<p><a class="reference internal" href="selectable.html#sqlalchemy.sql.expression.intersect" title="sqlalchemy.sql.expression.intersect"><code class="xref py py-func docutils literal notranslate"><span class="pre">intersect()</span></code></a></p>
<p><a class="reference internal" href="selectable.html#sqlalchemy.sql.expression.intersect_all" title="sqlalchemy.sql.expression.intersect_all"><code class="xref py py-func docutils literal notranslate"><span class="pre">intersect_all()</span></code></a></p>
<p><a class="reference internal" href="selectable.html#sqlalchemy.sql.expression.except_" title="sqlalchemy.sql.expression.except_"><code class="xref py py-func docutils literal notranslate"><span class="pre">except_()</span></code></a></p>
<p class="last"><a class="reference internal" href="selectable.html#sqlalchemy.sql.expression.except_all" title="sqlalchemy.sql.expression.except_all"><code class="xref py py-func docutils literal notranslate"><span class="pre">except_all()</span></code></a></p>
</div>
</div>
<div class="section" id="scalar-selects">
<span id="id2"></span><h3>Scalar Selects<a class="headerlink" href="#scalar-selects" title="제목 주소">¶</a></h3>
<p>A scalar select is a SELECT that returns exactly one row and one
column.  It can then be used as a column expression.  A scalar select
is often a <a class="reference internal" href="../glossary.html#term-correlated-subquery"><span class="xref std std-term">correlated subquery</span></a>, which relies upon the enclosing
SELECT statement in order to acquire at least one of its FROM clauses.</p>
<p>The <a class="reference internal" href="selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> construct can be modified to act as a
column expression by calling either the <a class="reference internal" href="selectable.html#sqlalchemy.sql.expression.SelectBase.as_scalar" title="sqlalchemy.sql.expression.SelectBase.as_scalar"><code class="xref py py-meth docutils literal notranslate"><span class="pre">as_scalar()</span></code></a>
or <a class="reference internal" href="selectable.html#sqlalchemy.sql.expression.SelectBase.label" title="sqlalchemy.sql.expression.SelectBase.label"><code class="xref py py-meth docutils literal notranslate"><span class="pre">label()</span></code></a> method:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span><span class="n">func</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">)])</span><span class="o">.</span>\
<span class="gp">... </span>            <span class="n">where</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">user_id</span><span class="p">)</span><span class="o">.</span>\
<span class="gp">... </span>            <span class="n">as_scalar</span><span class="p">()</span>
</pre></div>
</div>
<p>The above construct is now a <a class="reference internal" href="selectable.html#sqlalchemy.sql.expression.ScalarSelect" title="sqlalchemy.sql.expression.ScalarSelect"><code class="xref py py-class docutils literal notranslate"><span class="pre">ScalarSelect</span></code></a> object,
and is no longer part of the <a class="reference internal" href="selectable.html#sqlalchemy.sql.expression.FromClause" title="sqlalchemy.sql.expression.FromClause"><code class="xref py py-class docutils literal notranslate"><span class="pre">FromClause</span></code></a> hierarchy;
it instead is within the <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.expression.ColumnElement" title="sqlalchemy.sql.expression.ColumnElement"><code class="xref py py-class docutils literal notranslate"><span class="pre">ColumnElement</span></code></a> family of
expression constructs.  We can place this construct the same as any
other column within another <a class="reference internal" href="selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a>:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">select</span><span class="p">([</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">stmt</span><span class="p">]))</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>
<span class=" -Sql -Sql-Open">{opensql}</span><span class=" -Sql">SELECT users.name, (SELECT count(addresses.id) AS count_1</span>
<span class=" -Sql">FROM addresses</span>
<span class=" -Sql">WHERE users.id = addresses.user_id) AS anon_1</span>
<span class=" -Sql">FROM users</span>
<span class=" -Sql">()</span>
<span class=" -Sql">{stop}</span><span class="go">[(u&#39;jack&#39;, 2), (u&#39;wendy&#39;, 2)]</span>
</pre></div>
</div>
<p>To apply a non-anonymous column name to our scalar select, we create
it using <a class="reference internal" href="selectable.html#sqlalchemy.sql.expression.SelectBase.label" title="sqlalchemy.sql.expression.SelectBase.label"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SelectBase.label()</span></code></a> instead:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span><span class="n">func</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">)])</span><span class="o">.</span>\
<span class="gp">... </span>            <span class="n">where</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">user_id</span><span class="p">)</span><span class="o">.</span>\
<span class="gp">... </span>            <span class="n">label</span><span class="p">(</span><span class="s2">&quot;address_count&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">select</span><span class="p">([</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">stmt</span><span class="p">]))</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>
<span class=" -Sql -Sql-Open">{opensql}</span><span class=" -Sql">SELECT users.name, (SELECT count(addresses.id) AS count_1</span>
<span class=" -Sql">FROM addresses</span>
<span class=" -Sql">WHERE users.id = addresses.user_id) AS address_count</span>
<span class=" -Sql">FROM users</span>
<span class=" -Sql">()</span>
<span class=" -Sql">{stop}</span><span class="go">[(u&#39;jack&#39;, 2), (u&#39;wendy&#39;, 2)]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">더 보기</p>
<p><a class="reference internal" href="selectable.html#sqlalchemy.sql.expression.Select.as_scalar" title="sqlalchemy.sql.expression.Select.as_scalar"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.as_scalar()</span></code></a></p>
<p class="last"><a class="reference internal" href="selectable.html#sqlalchemy.sql.expression.Select.label" title="sqlalchemy.sql.expression.Select.label"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.label()</span></code></a></p>
</div>
</div>
<div class="section" id="correlated-subqueries">
<span id="id3"></span><h3>Correlated Subqueries<a class="headerlink" href="#correlated-subqueries" title="제목 주소">¶</a></h3>
<p>Notice in the examples on <a class="reference internal" href="#scalar-selects"><span class="std std-ref">Scalar Selects</span></a>, the FROM clause of each embedded
select did not contain the <code class="docutils literal notranslate"><span class="pre">users</span></code> table in its FROM clause. This is because
SQLAlchemy automatically <a class="reference internal" href="../glossary.html#term-correlates"><span class="xref std std-term">correlates</span></a> embedded FROM objects to that
of an enclosing query, if present, and if the inner SELECT statement would
still have at least one FROM clause of its own.  For example:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span><span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">user_id</span><span class="p">])</span><span class="o">.</span>\
<span class="gp">... </span>            <span class="n">where</span><span class="p">(</span><span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">user_id</span> <span class="o">==</span> <span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">)</span><span class="o">.</span>\
<span class="gp">... </span>            <span class="n">where</span><span class="p">(</span><span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">email_address</span> <span class="o">==</span> <span class="s1">&#39;jack@yahoo.com&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enclosing_stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">])</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">stmt</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">enclosing_stmt</span><span class="p">)</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>
<span class=" -Sql -Sql-Open">{opensql}</span><span class=" -Sql">SELECT users.name</span>
<span class=" -Sql">FROM users</span>
<span class=" -Sql">WHERE users.id = (SELECT addresses.user_id</span>
<span class=" -Sql">    FROM addresses</span>
<span class=" -Sql">    WHERE addresses.user_id = users.id</span>
<span class=" -Sql">    AND addresses.email_address = ?)</span>
<span class=" -Sql">(&#39;jack@yahoo.com&#39;,)</span>
<span class=" -Sql">{stop}</span><span class="go">[(u&#39;jack&#39;,)]</span>
</pre></div>
</div>
<p>Auto-correlation will usually do what's expected, however it can also be controlled.
For example, if we wanted a statement to correlate only to the <code class="docutils literal notranslate"><span class="pre">addresses</span></code> table
but not the <code class="docutils literal notranslate"><span class="pre">users</span></code> table, even if both were present in the enclosing SELECT,
we use the <a class="reference internal" href="selectable.html#sqlalchemy.sql.expression.Select.correlate" title="sqlalchemy.sql.expression.Select.correlate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">correlate()</span></code></a> method to specify those FROM clauses that
may be correlated:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">])</span><span class="o">.</span>\
<span class="gp">... </span>            <span class="n">where</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">user_id</span><span class="p">)</span><span class="o">.</span>\
<span class="gp">... </span>            <span class="n">where</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;jack&#39;</span><span class="p">)</span><span class="o">.</span>\
<span class="gp">... </span>            <span class="n">correlate</span><span class="p">(</span><span class="n">addresses</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enclosing_stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span>
<span class="gp">... </span>        <span class="p">[</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">email_address</span><span class="p">])</span><span class="o">.</span>\
<span class="gp">... </span>    <span class="n">select_from</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">addresses</span><span class="p">))</span><span class="o">.</span>\
<span class="gp">... </span>    <span class="n">where</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">stmt</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">enclosing_stmt</span><span class="p">)</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>
<span class=" -Sql -Sql-Open">{opensql}</span><span class=" -Sql">SELECT users.name, addresses.email_address</span>
<span class=" -Sql"> FROM users JOIN addresses ON users.id = addresses.user_id</span>
<span class=" -Sql"> WHERE users.id = (SELECT users.id</span>
<span class=" -Sql"> FROM users</span>
<span class=" -Sql"> WHERE users.id = addresses.user_id AND users.name = ?)</span>
<span class=" -Sql"> (&#39;jack&#39;,)</span>
<span class=" -Sql"> {stop}</span><span class="go">[(u&#39;jack&#39;, u&#39;jack@yahoo.com&#39;), (u&#39;jack&#39;, u&#39;jack@msn.com&#39;)]</span>
</pre></div>
</div>
<p>To entirely disable a statement from correlating, we can pass <code class="docutils literal notranslate"><span class="pre">None</span></code>
as the argument:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">])</span><span class="o">.</span>\
<span class="gp">... </span>            <span class="n">where</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;wendy&#39;</span><span class="p">)</span><span class="o">.</span>\
<span class="gp">... </span>            <span class="n">correlate</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enclosing_stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">])</span><span class="o">.</span>\
<span class="gp">... </span>    <span class="n">where</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">stmt</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">enclosing_stmt</span><span class="p">)</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>
<span class=" -Sql -Sql-Open">{opensql}</span><span class=" -Sql">SELECT users.name</span>
<span class=" -Sql"> FROM users</span>
<span class=" -Sql"> WHERE users.id = (SELECT users.id</span>
<span class=" -Sql">  FROM users</span>
<span class=" -Sql">  WHERE users.name = ?)</span>
<span class=" -Sql">(&#39;wendy&#39;,)</span>
<span class=" -Sql">{stop}</span><span class="go">[(u&#39;wendy&#39;,)]</span>
</pre></div>
</div>
<p>We can also control correlation via exclusion, using the <a class="reference internal" href="selectable.html#sqlalchemy.sql.expression.Select.correlate_except" title="sqlalchemy.sql.expression.Select.correlate_except"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.correlate_except()</span></code></a>
method.   Such as, we can write our SELECT for the <code class="docutils literal notranslate"><span class="pre">users</span></code> table
by telling it to correlate all FROM clauses except for <code class="docutils literal notranslate"><span class="pre">users</span></code>:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">])</span><span class="o">.</span>\
<span class="gp">... </span>            <span class="n">where</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">user_id</span><span class="p">)</span><span class="o">.</span>\
<span class="gp">... </span>            <span class="n">where</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;jack&#39;</span><span class="p">)</span><span class="o">.</span>\
<span class="gp">... </span>            <span class="n">correlate_except</span><span class="p">(</span><span class="n">users</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enclosing_stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span>
<span class="gp">... </span>        <span class="p">[</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">email_address</span><span class="p">])</span><span class="o">.</span>\
<span class="gp">... </span>    <span class="n">select_from</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">addresses</span><span class="p">))</span><span class="o">.</span>\
<span class="gp">... </span>    <span class="n">where</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">stmt</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">enclosing_stmt</span><span class="p">)</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>
<span class=" -Sql -Sql-Open">{opensql}</span><span class=" -Sql">SELECT users.name, addresses.email_address</span>
<span class=" -Sql"> FROM users JOIN addresses ON users.id = addresses.user_id</span>
<span class=" -Sql"> WHERE users.id = (SELECT users.id</span>
<span class=" -Sql"> FROM users</span>
<span class=" -Sql"> WHERE users.id = addresses.user_id AND users.name = ?)</span>
<span class=" -Sql"> (&#39;jack&#39;,)</span>
<span class=" -Sql"> {stop}</span><span class="go">[(u&#39;jack&#39;, u&#39;jack@yahoo.com&#39;), (u&#39;jack&#39;, u&#39;jack@msn.com&#39;)]</span>
</pre></div>
</div>
<div class="section" id="lateral-correlation">
<span id="lateral-selects"></span><h4>LATERAL correlation<a class="headerlink" href="#lateral-correlation" title="제목 주소">¶</a></h4>
<p>LATERAL correlation is a special sub-category of SQL correlation which
allows a selectable unit to refer to another selectable unit within a
single FROM clause.  This is an extremely special use case which, while
part of the SQL standard, is only known to be supported by recent
versions of PostgreSQL.</p>
<p>Normally, if a SELECT statement refers to
<code class="docutils literal notranslate"><span class="pre">table1</span> <span class="pre">JOIN</span> <span class="pre">(some</span> <span class="pre">SELECT)</span> <span class="pre">AS</span> <span class="pre">subquery</span></code> in its FROM clause, the subquery
on the right side may not refer to the &quot;table1&quot; expression from the left side;
correlation may only refer to a table that is part of another SELECT that
entirely encloses this SELECT.  The LATERAL keyword allows us to turn this
behavior around, allowing an expression such as:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span> <span class="n">people</span><span class="p">.</span><span class="n">people_id</span><span class="p">,</span> <span class="n">people</span><span class="p">.</span><span class="n">age</span><span class="p">,</span> <span class="n">people</span><span class="p">.</span><span class="n">name</span>
<span class="k">FROM</span> <span class="n">people</span> <span class="k">JOIN</span> <span class="k">LATERAL</span> <span class="p">(</span><span class="k">SELECT</span> <span class="n">books</span><span class="p">.</span><span class="n">book_id</span> <span class="k">AS</span> <span class="n">book_id</span>
<span class="k">FROM</span> <span class="n">books</span> <span class="k">WHERE</span> <span class="n">books</span><span class="p">.</span><span class="n">owner_id</span> <span class="o">=</span> <span class="n">people</span><span class="p">.</span><span class="n">people_id</span><span class="p">)</span>
<span class="k">AS</span> <span class="n">book_subq</span> <span class="k">ON</span> <span class="k">true</span>
</pre></div>
</div>
<p>Where above, the right side of the JOIN contains a subquery that refers not
just to the &quot;books&quot; table but also the &quot;people&quot; table, correlating
to the left side of the JOIN.   SQLAlchemy Core supports a statement
like the above using the <a class="reference internal" href="selectable.html#sqlalchemy.sql.expression.Select.lateral" title="sqlalchemy.sql.expression.Select.lateral"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.lateral()</span></code></a> method as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">table</span><span class="p">,</span> <span class="n">column</span><span class="p">,</span> <span class="n">select</span><span class="p">,</span> <span class="n">true</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">people</span> <span class="o">=</span> <span class="n">table</span><span class="p">(</span><span class="s1">&#39;people&#39;</span><span class="p">,</span> <span class="n">column</span><span class="p">(</span><span class="s1">&#39;people_id&#39;</span><span class="p">),</span> <span class="n">column</span><span class="p">(</span><span class="s1">&#39;age&#39;</span><span class="p">),</span> <span class="n">column</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">books</span> <span class="o">=</span> <span class="n">table</span><span class="p">(</span><span class="s1">&#39;books&#39;</span><span class="p">,</span> <span class="n">column</span><span class="p">(</span><span class="s1">&#39;book_id&#39;</span><span class="p">),</span> <span class="n">column</span><span class="p">(</span><span class="s1">&#39;owner_id&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subq</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span><span class="n">books</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">book_id</span><span class="p">])</span><span class="o">.</span>\
<span class="gp">... </span>     <span class="n">where</span><span class="p">(</span><span class="n">books</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">owner_id</span> <span class="o">==</span> <span class="n">people</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">people_id</span><span class="p">)</span><span class="o">.</span><span class="n">lateral</span><span class="p">(</span><span class="s2">&quot;book_subq&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">select</span><span class="p">([</span><span class="n">people</span><span class="p">])</span><span class="o">.</span><span class="n">select_from</span><span class="p">(</span><span class="n">people</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">subq</span><span class="p">,</span> <span class="n">true</span><span class="p">())))</span>
<span class="go">SELECT people.people_id, people.age, people.name</span>
<span class="go">FROM people JOIN LATERAL (SELECT books.book_id AS book_id</span>
<span class="go">FROM books WHERE books.owner_id = people.people_id)</span>
<span class="go">AS book_subq ON true</span>
</pre></div>
</div>
<p>Above, we can see that the <a class="reference internal" href="selectable.html#sqlalchemy.sql.expression.Select.lateral" title="sqlalchemy.sql.expression.Select.lateral"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.lateral()</span></code></a> method acts a lot like
the <a class="reference internal" href="selectable.html#sqlalchemy.sql.expression.Select.alias" title="sqlalchemy.sql.expression.Select.alias"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.alias()</span></code></a> method, including that we can specify an optional
name.  However the construct is the <a class="reference internal" href="selectable.html#sqlalchemy.sql.expression.Lateral" title="sqlalchemy.sql.expression.Lateral"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lateral</span></code></a> construct instead of
an <a class="reference internal" href="selectable.html#sqlalchemy.sql.expression.Alias" title="sqlalchemy.sql.expression.Alias"><code class="xref py py-class docutils literal notranslate"><span class="pre">Alias</span></code></a> which provides for the LATERAL keyword as well as special
instructions to allow correlation from inside the FROM clause of the
enclosing statement.</p>
<p>The <a class="reference internal" href="selectable.html#sqlalchemy.sql.expression.Select.lateral" title="sqlalchemy.sql.expression.Select.lateral"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.lateral()</span></code></a> method interacts normally with the
<a class="reference internal" href="selectable.html#sqlalchemy.sql.expression.Select.correlate" title="sqlalchemy.sql.expression.Select.correlate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.correlate()</span></code></a> and <a class="reference internal" href="selectable.html#sqlalchemy.sql.expression.Select.correlate_except" title="sqlalchemy.sql.expression.Select.correlate_except"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.correlate_except()</span></code></a> methods, except
that the correlation rules also apply to any other tables present in the
enclosing statement's FROM clause.   Correlation is &quot;automatic&quot; to these
tables by default, is explicit if the table is specified to
<a class="reference internal" href="selectable.html#sqlalchemy.sql.expression.Select.correlate" title="sqlalchemy.sql.expression.Select.correlate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.correlate()</span></code></a>, and is explicit to all tables except those
specified to <a class="reference internal" href="selectable.html#sqlalchemy.sql.expression.Select.correlate_except" title="sqlalchemy.sql.expression.Select.correlate_except"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.correlate_except()</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 1.1에 추가: </span>Support for the LATERAL keyword and lateral correlation.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">더 보기</p>
<p><a class="reference internal" href="selectable.html#sqlalchemy.sql.expression.Lateral" title="sqlalchemy.sql.expression.Lateral"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lateral</span></code></a></p>
<p class="last"><a class="reference internal" href="selectable.html#sqlalchemy.sql.expression.Select.lateral" title="sqlalchemy.sql.expression.Select.lateral"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.lateral()</span></code></a></p>
</div>
</div>
</div>
<div class="section" id="ordering-grouping-limiting-offset-ing">
<h3>Ordering, Grouping, Limiting, Offset...ing...<a class="headerlink" href="#ordering-grouping-limiting-offset-ing" title="제목 주소">¶</a></h3>
<p>Ordering is done by passing column expressions to the
<code class="xref py py-meth docutils literal notranslate"><span class="pre">order_by()</span></code> method:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">])</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>
<span class=" -Sql -Sql-Open">{opensql}</span><span class=" -Sql">SELECT users.name</span>
<span class=" -Sql">FROM users ORDER BY users.name</span>
<span class=" -Sql">()</span>
<span class=" -Sql">{stop}</span><span class="go">[(u&#39;jack&#39;,), (u&#39;wendy&#39;,)]</span>
</pre></div>
</div>
<p>Ascending or descending can be controlled using the <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.expression.ColumnElement.asc" title="sqlalchemy.sql.expression.ColumnElement.asc"><code class="xref py py-meth docutils literal notranslate"><span class="pre">asc()</span></code></a>
and <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.expression.ColumnElement.desc" title="sqlalchemy.sql.expression.ColumnElement.desc"><code class="xref py py-meth docutils literal notranslate"><span class="pre">desc()</span></code></a> modifiers:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">])</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">desc</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>
<span class=" -Sql -Sql-Open">{opensql}</span><span class=" -Sql">SELECT users.name</span>
<span class=" -Sql">FROM users ORDER BY users.name DESC</span>
<span class=" -Sql">()</span>
<span class=" -Sql">{stop}</span><span class="go">[(u&#39;wendy&#39;,), (u&#39;jack&#39;,)]</span>
</pre></div>
</div>
<p>Grouping refers to the GROUP BY clause, and is usually used in conjunction
with aggregate functions to establish groups of rows to be aggregated.
This is provided via the <code class="xref py py-meth docutils literal notranslate"><span class="pre">group_by()</span></code> method:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">func</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">)])</span><span class="o">.</span>\
<span class="gp">... </span>            <span class="n">select_from</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">addresses</span><span class="p">))</span><span class="o">.</span>\
<span class="gp">... </span>            <span class="n">group_by</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>
<span class=" -Sql -Sql-Open">{opensql}</span><span class=" -Sql">SELECT users.name, count(addresses.id) AS count_1</span>
<span class=" -Sql">FROM users JOIN addresses</span>
<span class=" -Sql">    ON users.id = addresses.user_id</span>
<span class=" -Sql">GROUP BY users.name</span>
<span class=" -Sql">()</span>
<span class=" -Sql">{stop}</span><span class="go">[(u&#39;jack&#39;, 2), (u&#39;wendy&#39;, 2)]</span>
</pre></div>
</div>
<p>HAVING can be used to filter results on an aggregate value, after GROUP BY has
been applied.  It's available here via the <a class="reference internal" href="selectable.html#sqlalchemy.sql.expression.Select.having" title="sqlalchemy.sql.expression.Select.having"><code class="xref py py-meth docutils literal notranslate"><span class="pre">having()</span></code></a>
method:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">func</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">)])</span><span class="o">.</span>\
<span class="gp">... </span>            <span class="n">select_from</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">addresses</span><span class="p">))</span><span class="o">.</span>\
<span class="gp">... </span>            <span class="n">group_by</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">)</span><span class="o">.</span>\
<span class="gp">... </span>            <span class="n">having</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">length</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>
<span class=" -Sql -Sql-Open">{opensql}</span><span class=" -Sql">SELECT users.name, count(addresses.id) AS count_1</span>
<span class=" -Sql">FROM users JOIN addresses</span>
<span class=" -Sql">    ON users.id = addresses.user_id</span>
<span class=" -Sql">GROUP BY users.name</span>
<span class=" -Sql">HAVING length(users.name) &gt; ?</span>
<span class=" -Sql">(4,)</span>
<span class=" -Sql">{stop}</span><span class="go">[(u&#39;wendy&#39;, 2)]</span>
</pre></div>
</div>
<p>A common system of dealing with duplicates in composed SELECT statements
is the DISTINCT modifier.  A simple DISTINCT clause can be added using the
<a class="reference internal" href="selectable.html#sqlalchemy.sql.expression.Select.distinct" title="sqlalchemy.sql.expression.Select.distinct"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.distinct()</span></code></a> method:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">])</span><span class="o">.</span>\
<span class="gp">... </span>            <span class="n">where</span><span class="p">(</span><span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">email_address</span><span class="o">.</span>
<span class="gp">... </span>                   <span class="n">contains</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">))</span><span class="o">.</span>\
<span class="gp">... </span>            <span class="n">distinct</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>
<span class=" -Sql -Sql-Open">{opensql}</span><span class=" -Sql">SELECT DISTINCT users.name</span>
<span class=" -Sql">FROM users, addresses</span>
<span class=" -Sql">WHERE (addresses.email_address LIKE &#39;%&#39; || users.name || &#39;%&#39;)</span>
<span class=" -Sql">()</span>
<span class=" -Sql">{stop}</span><span class="go">[(u&#39;jack&#39;,), (u&#39;wendy&#39;,)]</span>
</pre></div>
</div>
<p>Most database backends support a system of limiting how many rows
are returned, and the majority also feature a means of starting to return
rows after a given &quot;offset&quot;.   While common backends like PostgreSQL,
MySQL and SQLite support LIMIT and OFFSET keywords, other backends
need to refer to more esoteric features such as &quot;window functions&quot;
and row ids to achieve the same effect.  The <a class="reference internal" href="selectable.html#sqlalchemy.sql.expression.Select.limit" title="sqlalchemy.sql.expression.Select.limit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">limit()</span></code></a>
and <a class="reference internal" href="selectable.html#sqlalchemy.sql.expression.Select.offset" title="sqlalchemy.sql.expression.Select.offset"><code class="xref py py-meth docutils literal notranslate"><span class="pre">offset()</span></code></a> methods provide an easy abstraction
into the current backend's methodology:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">email_address</span><span class="p">])</span><span class="o">.</span>\
<span class="gp">... </span>            <span class="n">select_from</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">addresses</span><span class="p">))</span><span class="o">.</span>\
<span class="gp">... </span>            <span class="n">limit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">offset</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>
<span class=" -Sql -Sql-Open">{opensql}</span><span class=" -Sql">SELECT users.name, addresses.email_address</span>
<span class=" -Sql">FROM users JOIN addresses ON users.id = addresses.user_id</span>
<span class=" -Sql"> LIMIT ? OFFSET ?</span>
<span class=" -Sql">(1, 1)</span>
<span class=" -Sql">{stop}</span><span class="go">[(u&#39;jack&#39;, u&#39;jack@msn.com&#39;)]</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="inserts-updates-and-deletes">
<span id="inserts-and-updates"></span><h2>Inserts, Updates and Deletes<a class="headerlink" href="#inserts-updates-and-deletes" title="제목 주소">¶</a></h2>
<p>We've seen <a class="reference internal" href="selectable.html#sqlalchemy.sql.expression.TableClause.insert" title="sqlalchemy.sql.expression.TableClause.insert"><code class="xref py py-meth docutils literal notranslate"><span class="pre">insert()</span></code></a> demonstrated
earlier in this tutorial.   Where <a class="reference internal" href="selectable.html#sqlalchemy.sql.expression.TableClause.insert" title="sqlalchemy.sql.expression.TableClause.insert"><code class="xref py py-meth docutils literal notranslate"><span class="pre">insert()</span></code></a>
produces INSERT, the <a class="reference internal" href="selectable.html#sqlalchemy.sql.expression.TableClause.update" title="sqlalchemy.sql.expression.TableClause.update"><code class="xref py py-meth docutils literal notranslate"><span class="pre">update()</span></code></a>
method produces UPDATE.  Both of these constructs feature
a method called <a class="reference internal" href="dml.html#sqlalchemy.sql.expression.ValuesBase.values" title="sqlalchemy.sql.expression.ValuesBase.values"><code class="xref py py-meth docutils literal notranslate"><span class="pre">values()</span></code></a> which specifies
the VALUES or SET clause of the statement.</p>
<p>The <a class="reference internal" href="dml.html#sqlalchemy.sql.expression.ValuesBase.values" title="sqlalchemy.sql.expression.ValuesBase.values"><code class="xref py py-meth docutils literal notranslate"><span class="pre">values()</span></code></a> method accommodates any column expression
as a value:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="n">users</span><span class="o">.</span><span class="n">update</span><span class="p">()</span><span class="o">.</span>\
<span class="gp">... </span>            <span class="n">values</span><span class="p">(</span><span class="n">fullname</span><span class="o">=</span><span class="s2">&quot;Fullname: &quot;</span> <span class="o">+</span> <span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span>
<span class=" -Sql -Sql-Open">{opensql}</span><span class=" -Sql">UPDATE users SET fullname=(? || users.name)</span>
<span class=" -Sql">(&#39;Fullname: &#39;,)</span>
<span class=" -Sql">COMMIT</span>
<span class=" -Sql">{stop}</span><span class="go">&lt;sqlalchemy.engine.result.ResultProxy object at 0x...&gt;</span>
</pre></div>
</div>
<p>When using <a class="reference internal" href="selectable.html#sqlalchemy.sql.expression.TableClause.insert" title="sqlalchemy.sql.expression.TableClause.insert"><code class="xref py py-meth docutils literal notranslate"><span class="pre">insert()</span></code></a> or <a class="reference internal" href="selectable.html#sqlalchemy.sql.expression.TableClause.update" title="sqlalchemy.sql.expression.TableClause.update"><code class="xref py py-meth docutils literal notranslate"><span class="pre">update()</span></code></a>
in an &quot;execute many&quot; context, we may also want to specify named
bound parameters which we can refer to in the argument list.
The two constructs will automatically generate bound placeholders
for any column names passed in the dictionaries sent to
<a class="reference internal" href="connections.html#sqlalchemy.engine.Connection.execute" title="sqlalchemy.engine.Connection.execute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">execute()</span></code></a> at execution time.  However, if we
wish to use explicitly targeted named parameters with composed expressions,
we need to use the <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.expression.bindparam" title="sqlalchemy.sql.expression.bindparam"><code class="xref py py-func docutils literal notranslate"><span class="pre">bindparam()</span></code></a> construct.
When using <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.expression.bindparam" title="sqlalchemy.sql.expression.bindparam"><code class="xref py py-func docutils literal notranslate"><span class="pre">bindparam()</span></code></a> with
<a class="reference internal" href="selectable.html#sqlalchemy.sql.expression.TableClause.insert" title="sqlalchemy.sql.expression.TableClause.insert"><code class="xref py py-meth docutils literal notranslate"><span class="pre">insert()</span></code></a> or <a class="reference internal" href="selectable.html#sqlalchemy.sql.expression.TableClause.update" title="sqlalchemy.sql.expression.TableClause.update"><code class="xref py py-meth docutils literal notranslate"><span class="pre">update()</span></code></a>,
the names of the table's columns themselves are reserved for the
&quot;automatic&quot; generation of bind names.  We can combine the usage
of implicitly available bind names and explicitly named parameters
as in the example below:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="n">users</span><span class="o">.</span><span class="n">insert</span><span class="p">()</span><span class="o">.</span>\
<span class="gp">... </span>        <span class="n">values</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">bindparam</span><span class="p">(</span><span class="s1">&#39;_name&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; .. name&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="p">[</span>
<span class="gp">... </span>       <span class="p">{</span><span class="s1">&#39;id&#39;</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;_name&#39;</span><span class="p">:</span><span class="s1">&#39;name1&#39;</span><span class="p">},</span>
<span class="gp">... </span>       <span class="p">{</span><span class="s1">&#39;id&#39;</span><span class="p">:</span><span class="mi">5</span><span class="p">,</span> <span class="s1">&#39;_name&#39;</span><span class="p">:</span><span class="s1">&#39;name2&#39;</span><span class="p">},</span>
<span class="gp">... </span>       <span class="p">{</span><span class="s1">&#39;id&#39;</span><span class="p">:</span><span class="mi">6</span><span class="p">,</span> <span class="s1">&#39;_name&#39;</span><span class="p">:</span><span class="s1">&#39;name3&#39;</span><span class="p">},</span>
<span class="gp">... </span>    <span class="p">])</span>
<span class=" -Sql -Sql-Open">{opensql}</span><span class=" -Sql">INSERT INTO users (id, name) VALUES (?, (? || ?))</span>
<span class=" -Sql">((4, &#39;name1&#39;, &#39; .. name&#39;), (5, &#39;name2&#39;, &#39; .. name&#39;), (6, &#39;name3&#39;, &#39; .. name&#39;))</span>
<span class=" -Sql">COMMIT</span>
<span class=" -Sql">&lt;sqlalchemy.engine.result.ResultProxy object at 0x...&gt;</span><span class="go"></span>
</pre></div>
</div>
<p>An UPDATE statement is emitted using the <a class="reference internal" href="selectable.html#sqlalchemy.sql.expression.TableClause.update" title="sqlalchemy.sql.expression.TableClause.update"><code class="xref py py-meth docutils literal notranslate"><span class="pre">update()</span></code></a> construct.  This
works much like an INSERT, except there is an additional WHERE clause
that can be specified:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="n">users</span><span class="o">.</span><span class="n">update</span><span class="p">()</span><span class="o">.</span>\
<span class="gp">... </span>            <span class="n">where</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;jack&#39;</span><span class="p">)</span><span class="o">.</span>\
<span class="gp">... </span>            <span class="n">values</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;ed&#39;</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span>
<span class=" -Sql -Sql-Open">{opensql}</span><span class=" -Sql">UPDATE users SET name=? WHERE users.name = ?</span>
<span class=" -Sql">(&#39;ed&#39;, &#39;jack&#39;)</span>
<span class=" -Sql">COMMIT</span>
<span class=" -Sql">{stop}</span><span class="go">&lt;sqlalchemy.engine.result.ResultProxy object at 0x...&gt;</span>
</pre></div>
</div>
<p>When using <a class="reference internal" href="selectable.html#sqlalchemy.sql.expression.TableClause.update" title="sqlalchemy.sql.expression.TableClause.update"><code class="xref py py-meth docutils literal notranslate"><span class="pre">update()</span></code></a> in an &quot;executemany&quot; context,
we may wish to also use explicitly named bound parameters in the
WHERE clause.  Again, <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.expression.bindparam" title="sqlalchemy.sql.expression.bindparam"><code class="xref py py-func docutils literal notranslate"><span class="pre">bindparam()</span></code></a> is the construct
used to achieve this:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="n">users</span><span class="o">.</span><span class="n">update</span><span class="p">()</span><span class="o">.</span>\
<span class="gp">... </span>            <span class="n">where</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">bindparam</span><span class="p">(</span><span class="s1">&#39;oldname&#39;</span><span class="p">))</span><span class="o">.</span>\
<span class="gp">... </span>            <span class="n">values</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">bindparam</span><span class="p">(</span><span class="s1">&#39;newname&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="p">[</span>
<span class="gp">... </span>    <span class="p">{</span><span class="s1">&#39;oldname&#39;</span><span class="p">:</span><span class="s1">&#39;jack&#39;</span><span class="p">,</span> <span class="s1">&#39;newname&#39;</span><span class="p">:</span><span class="s1">&#39;ed&#39;</span><span class="p">},</span>
<span class="gp">... </span>    <span class="p">{</span><span class="s1">&#39;oldname&#39;</span><span class="p">:</span><span class="s1">&#39;wendy&#39;</span><span class="p">,</span> <span class="s1">&#39;newname&#39;</span><span class="p">:</span><span class="s1">&#39;mary&#39;</span><span class="p">},</span>
<span class="gp">... </span>    <span class="p">{</span><span class="s1">&#39;oldname&#39;</span><span class="p">:</span><span class="s1">&#39;jim&#39;</span><span class="p">,</span> <span class="s1">&#39;newname&#39;</span><span class="p">:</span><span class="s1">&#39;jake&#39;</span><span class="p">},</span>
<span class="gp">... </span>    <span class="p">])</span>
<span class=" -Sql -Sql-Open">{opensql}</span><span class=" -Sql">UPDATE users SET name=? WHERE users.name = ?</span>
<span class=" -Sql">((&#39;ed&#39;, &#39;jack&#39;), (&#39;mary&#39;, &#39;wendy&#39;), (&#39;jake&#39;, &#39;jim&#39;))</span>
<span class=" -Sql">COMMIT</span>
<span class=" -Sql">{stop}</span><span class="go">&lt;sqlalchemy.engine.result.ResultProxy object at 0x...&gt;</span>
</pre></div>
</div>
<div class="section" id="correlated-updates">
<h3>Correlated Updates<a class="headerlink" href="#correlated-updates" title="제목 주소">¶</a></h3>
<p>A correlated update lets you update a table using selection from another
table, or the same table:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span><span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">email_address</span><span class="p">])</span><span class="o">.</span>\
<span class="gp">... </span>            <span class="n">where</span><span class="p">(</span><span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">user_id</span> <span class="o">==</span> <span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">)</span><span class="o">.</span>\
<span class="gp">... </span>            <span class="n">limit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">update</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="p">(</span><span class="n">fullname</span><span class="o">=</span><span class="n">stmt</span><span class="p">))</span>
<span class=" -Sql -Sql-Open">{opensql}</span><span class=" -Sql">UPDATE users SET fullname=(SELECT addresses.email_address</span>
<span class=" -Sql">    FROM addresses</span>
<span class=" -Sql">    WHERE addresses.user_id = users.id</span>
<span class=" -Sql">    LIMIT ? OFFSET ?)</span>
<span class=" -Sql">(1, 0)</span>
<span class=" -Sql">COMMIT</span>
<span class=" -Sql">{stop}</span><span class="go">&lt;sqlalchemy.engine.result.ResultProxy object at 0x...&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="multiple-table-updates">
<span id="multi-table-updates"></span><h3>Multiple Table Updates<a class="headerlink" href="#multiple-table-updates" title="제목 주소">¶</a></h3>
<p>The PostgreSQL, Microsoft SQL Server, and MySQL backends all support UPDATE statements
that refer to multiple tables.   For PG and MSSQL, this is the &quot;UPDATE FROM&quot; syntax,
which updates one table at a time, but can reference additional tables in an additional
&quot;FROM&quot; clause that can then be referenced in the WHERE clause directly.   On MySQL,
multiple tables can be embedded into a single UPDATE statement separated by a comma.
The SQLAlchemy <a class="reference internal" href="dml.html#sqlalchemy.sql.expression.update" title="sqlalchemy.sql.expression.update"><code class="xref py py-func docutils literal notranslate"><span class="pre">update()</span></code></a> construct supports both of these modes
implicitly, by specifying multiple tables in the WHERE clause:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">stmt</span> <span class="o">=</span> <span class="n">users</span><span class="o">.</span><span class="n">update</span><span class="p">()</span><span class="o">.</span>\
        <span class="n">values</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;ed wood&#39;</span><span class="p">)</span><span class="o">.</span>\
        <span class="n">where</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">)</span><span class="o">.</span>\
        <span class="n">where</span><span class="p">(</span><span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">email_address</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;ed%&#39;</span><span class="p">))</span>
<span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span>
</pre></div>
</div>
<p>The resulting SQL from the above statement would render as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">UPDATE</span> <span class="n">users</span> <span class="n">SET</span> <span class="n">name</span><span class="o">=</span><span class="p">:</span><span class="n">name</span> <span class="n">FROM</span> <span class="n">addresses</span>
<span class="n">WHERE</span> <span class="n">users</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">addresses</span><span class="o">.</span><span class="n">id</span> <span class="n">AND</span>
<span class="n">addresses</span><span class="o">.</span><span class="n">email_address</span> <span class="n">LIKE</span> <span class="p">:</span><span class="n">email_address_1</span> <span class="o">||</span> <span class="s1">&#39;%&#39;</span>
</pre></div>
</div>
<p>When using MySQL, columns from each table can be assigned to in the
SET clause directly, using the dictionary form passed to <a class="reference internal" href="dml.html#sqlalchemy.sql.expression.Update.values" title="sqlalchemy.sql.expression.Update.values"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Update.values()</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">stmt</span> <span class="o">=</span> <span class="n">users</span><span class="o">.</span><span class="n">update</span><span class="p">()</span><span class="o">.</span>\
        <span class="n">values</span><span class="p">({</span>
            <span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">:</span><span class="s1">&#39;ed wood&#39;</span><span class="p">,</span>
            <span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">email_address</span><span class="p">:</span><span class="s1">&#39;ed.wood@foo.com&#39;</span>
        <span class="p">})</span><span class="o">.</span>\
        <span class="n">where</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">)</span><span class="o">.</span>\
        <span class="n">where</span><span class="p">(</span><span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">email_address</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;ed%&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>The tables are referenced explicitly in the SET clause:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">UPDATE</span> <span class="n">users</span><span class="p">,</span> <span class="n">addresses</span> <span class="n">SET</span> <span class="n">addresses</span><span class="o">.</span><span class="n">email_address</span><span class="o">=%</span><span class="n">s</span><span class="p">,</span>
        <span class="n">users</span><span class="o">.</span><span class="n">name</span><span class="o">=%</span><span class="n">s</span> <span class="n">WHERE</span> <span class="n">users</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">addresses</span><span class="o">.</span><span class="n">id</span>
        <span class="n">AND</span> <span class="n">addresses</span><span class="o">.</span><span class="n">email_address</span> <span class="n">LIKE</span> <span class="n">concat</span><span class="p">(</span><span class="o">%</span><span class="n">s</span><span class="p">,</span> <span class="s1">&#39;%&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>When the construct is used on a non-supporting database, the compiler
will raise <code class="docutils literal notranslate"><span class="pre">NotImplementedError</span></code>.   For convenience, when a statement
is printed as a string without specification of a dialect, the &quot;string SQL&quot;
compiler will be invoked which provides a non-working SQL representation of the
construct.</p>
</div>
<div class="section" id="parameter-ordered-updates">
<span id="updates-order-parameters"></span><h3>Parameter-Ordered Updates<a class="headerlink" href="#parameter-ordered-updates" title="제목 주소">¶</a></h3>
<p>The default behavior of the <a class="reference internal" href="dml.html#sqlalchemy.sql.expression.update" title="sqlalchemy.sql.expression.update"><code class="xref py py-func docutils literal notranslate"><span class="pre">update()</span></code></a> construct when rendering the SET
clauses is to render them using the column ordering given in the
originating <a class="reference internal" href="metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> object.
This is an important behavior, since it means that the rendering of a
particular UPDATE statement with particular columns
will be rendered the same each time, which has an impact on query caching systems
that rely on the form of the statement, either client side or server side.
Since the parameters themselves are passed to the <a class="reference internal" href="dml.html#sqlalchemy.sql.expression.Update.values" title="sqlalchemy.sql.expression.Update.values"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Update.values()</span></code></a>
method as Python dictionary keys, there is no other fixed ordering
available.</p>
<p>However in some cases, the order of parameters rendered in the SET clause of an
UPDATE statement can be significant.  The main example of this is when using
MySQL and providing updates to column values based on that of other
column values.  The end result of the following statement:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">UPDATE</span> <span class="n">some_table</span> <span class="n">SET</span> <span class="n">x</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">10</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">20</span>
</pre></div>
</div>
<p>Will have a different result than:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">UPDATE</span> <span class="n">some_table</span> <span class="n">SET</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">10</span>
</pre></div>
</div>
<p>This because on MySQL, the individual SET clauses are fully evaluated on
a per-value basis, as opposed to on a per-row basis, and as each SET clause
is evaluated, the values embedded in the row are changing.</p>
<p>To suit this specific use case, the
<a class="reference internal" href="dml.html#sqlalchemy.sql.expression.update.params.preserve_parameter_order" title="sqlalchemy.sql.expression.update"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">preserve_parameter_order</span></code></a>
flag may be used.  When using this flag, we supply a <strong>Python list of 2-tuples</strong>
as the argument to the <a class="reference internal" href="dml.html#sqlalchemy.sql.expression.Update.values" title="sqlalchemy.sql.expression.Update.values"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Update.values()</span></code></a> method:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">stmt</span> <span class="o">=</span> <span class="n">some_table</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">preserve_parameter_order</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span>\
    <span class="n">values</span><span class="p">([(</span><span class="n">some_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="mi">20</span><span class="p">),</span> <span class="p">(</span><span class="n">some_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">some_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="mi">10</span><span class="p">)])</span>
</pre></div>
</div>
<p>The list of 2-tuples is essentially the same structure as a Python dictionary
except it is ordered.  Using the above form, we are assured that the
&quot;y&quot; column's SET clause will render first, then the &quot;x&quot; column's SET clause.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 1.0.10에 추가: </span>Added support for explicit ordering of UPDATE
parameters using the <a class="reference internal" href="dml.html#sqlalchemy.sql.expression.update.params.preserve_parameter_order" title="sqlalchemy.sql.expression.update"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">preserve_parameter_order</span></code></a> flag.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">더 보기</p>
<p class="last"><a class="reference internal" href="../dialects/mysql.html#mysql-insert-on-duplicate-key-update"><span class="std std-ref">INSERT...ON DUPLICATE KEY UPDATE (Upsert)</span></a> - background on the MySQL
<code class="docutils literal notranslate"><span class="pre">ON</span> <span class="pre">DUPLICATE</span> <span class="pre">KEY</span> <span class="pre">UPDATE</span></code> clause and how to support parameter ordering.</p>
</div>
</div>
<div class="section" id="deletes">
<span id="id4"></span><h3>Deletes<a class="headerlink" href="#deletes" title="제목 주소">¶</a></h3>
<p>Finally, a delete.  This is accomplished easily enough using the
<a class="reference internal" href="selectable.html#sqlalchemy.sql.expression.TableClause.delete" title="sqlalchemy.sql.expression.TableClause.delete"><code class="xref py py-meth docutils literal notranslate"><span class="pre">delete()</span></code></a> construct:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">addresses</span><span class="o">.</span><span class="n">delete</span><span class="p">())</span>
<span class=" -Sql -Sql-Open">{opensql}</span><span class=" -Sql">DELETE FROM addresses</span>
<span class=" -Sql">()</span>
<span class=" -Sql">COMMIT</span>
<span class=" -Sql">{stop}</span><span class="go">&lt;sqlalchemy.engine.result.ResultProxy object at 0x...&gt;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">delete</span><span class="p">()</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span> <span class="o">&gt;</span> <span class="s1">&#39;m&#39;</span><span class="p">))</span>
<span class=" -Sql -Sql-Open">{opensql}</span><span class=" -Sql">DELETE FROM users WHERE users.name &gt; ?</span>
<span class=" -Sql">(&#39;m&#39;,)</span>
<span class=" -Sql">COMMIT</span>
<span class=" -Sql">{stop}</span><span class="go">&lt;sqlalchemy.engine.result.ResultProxy object at 0x...&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="multiple-table-deletes">
<span id="multi-table-deletes"></span><h3>Multiple Table Deletes<a class="headerlink" href="#multiple-table-deletes" title="제목 주소">¶</a></h3>
<div class="versionadded">
<p><span class="versionmodified">버전 1.2에 추가.</span></p>
</div>
<p>The PostgreSQL, Microsoft SQL Server, and MySQL backends all support DELETE
statements that refer to multiple tables within the WHERE criteria.   For PG
and MySQL, this is the &quot;DELETE USING&quot; syntax, and for SQL Server, it's a
&quot;DELETE FROM&quot; that refers to more than one table.  The SQLAlchemy
<a class="reference internal" href="dml.html#sqlalchemy.sql.expression.delete" title="sqlalchemy.sql.expression.delete"><code class="xref py py-func docutils literal notranslate"><span class="pre">delete()</span></code></a> construct supports both of these modes
implicitly, by specifying multiple tables in the WHERE clause:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">stmt</span> <span class="o">=</span> <span class="n">users</span><span class="o">.</span><span class="n">delete</span><span class="p">()</span><span class="o">.</span>\
        <span class="n">where</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">)</span><span class="o">.</span>\
        <span class="n">where</span><span class="p">(</span><span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">email_address</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;ed%&#39;</span><span class="p">))</span>
<span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span>
</pre></div>
</div>
<p>On a PostgreSQL backend, the resulting SQL from the above statement would render as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">DELETE</span> <span class="n">FROM</span> <span class="n">users</span> <span class="n">USING</span> <span class="n">addresses</span>
<span class="n">WHERE</span> <span class="n">users</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">addresses</span><span class="o">.</span><span class="n">id</span>
<span class="n">AND</span> <span class="p">(</span><span class="n">addresses</span><span class="o">.</span><span class="n">email_address</span> <span class="n">LIKE</span> <span class="o">%</span><span class="p">(</span><span class="n">email_address_1</span><span class="p">)</span><span class="n">s</span> <span class="o">||</span> <span class="s1">&#39;</span><span class="si">%%</span><span class="s1">&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>When the construct is used on a non-supporting database, the compiler
will raise <code class="docutils literal notranslate"><span class="pre">NotImplementedError</span></code>.   For convenience, when a statement
is printed as a string without specification of a dialect, the &quot;string SQL&quot;
compiler will be invoked which provides a non-working SQL representation of the
construct.</p>
</div>
<div class="section" id="matched-row-counts">
<h3>Matched Row Counts<a class="headerlink" href="#matched-row-counts" title="제목 주소">¶</a></h3>
<p>Both of <a class="reference internal" href="selectable.html#sqlalchemy.sql.expression.TableClause.update" title="sqlalchemy.sql.expression.TableClause.update"><code class="xref py py-meth docutils literal notranslate"><span class="pre">update()</span></code></a> and
<a class="reference internal" href="selectable.html#sqlalchemy.sql.expression.TableClause.delete" title="sqlalchemy.sql.expression.TableClause.delete"><code class="xref py py-meth docutils literal notranslate"><span class="pre">delete()</span></code></a> are associated with <em>matched row counts</em>.  This is a
number indicating the number of rows that were matched by the WHERE clause.
Note that by &quot;matched&quot;, this includes rows where no UPDATE actually took place.
The value is available as <a class="reference internal" href="connections.html#sqlalchemy.engine.ResultProxy.rowcount" title="sqlalchemy.engine.ResultProxy.rowcount"><code class="xref py py-attr docutils literal notranslate"><span class="pre">rowcount</span></code></a>:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">delete</span><span class="p">())</span>
<span class=" -Sql -Sql-Open">{opensql}</span><span class=" -Sql">DELETE FROM users</span>
<span class=" -Sql">()</span>
<span class=" -Sql">COMMIT</span>
<span class=" -Sql">{stop}</span><span class="gp">&gt;&gt;&gt; </span><span class="n">result</span><span class="o">.</span><span class="n">rowcount</span>
<span class="go">1</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="further-reference">
<h2>Further Reference<a class="headerlink" href="#further-reference" title="제목 주소">¶</a></h2>
<p>Expression Language Reference: <a class="reference internal" href="expression_api.html#expression-api-toplevel"><span class="std std-ref">SQL Statements and Expressions API</span></a></p>
<p>Database Metadata Reference: <a class="reference internal" href="metadata.html#metadata-toplevel"><span class="std std-ref">Describing Databases with MetaData</span></a></p>
<p>Engine Reference: <a class="reference internal" href="engines.html"><span class="doc">Engine Configuration</span></a></p>
<p>Connection Reference: <a class="reference internal" href="connections.html#connections-toplevel"><span class="std std-ref">Working with Engines and Connections</span></a></p>
<p>Types Reference: <a class="reference internal" href="types.html#types-toplevel"><span class="std std-ref">Column and Data Types</span></a></p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="expression_api.html" class="btn btn-neutral float-right" title="SQL Statements and Expressions API" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="index.html" class="btn btn-neutral" title="SQLAlchemy Core" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; <a href="../copyright.html">Copyright</a> 2007-2018, the SQLAlchemy authors and contributors.
      최종 업데이트: 06/07/2019 11:12:12

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'1.3.0b1',
            LANGUAGE:'ko',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="../_static/language_data.js"></script>
      <script type="text/javascript" src="../_static/translations.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  <script type="text/javascript">
      jQuery(function () {
          
          SphinxRtdTheme.Navigation.enableSticky();
          
      });
  </script> 

</body>
</html>